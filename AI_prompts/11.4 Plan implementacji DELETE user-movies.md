Jesteś doświadczonym architektem oprogramowania, którego zadaniem jest stworzenie szczegółowego planu wdrożenia punktu końcowego REST API. Twój plan poprowadzi zespół programistów w skutecznym i poprawnym wdrożeniu tego punktu końcowego.

Zanim zaczniemy, zapoznaj się z poniższymi informacjami:

1. Route API specification:
<route_api_specification>
#### `DELETE /api/user-movies/<id>`
-   **Description**: Soft-deletes a movie from the user's watchlist. The record is not physically removed from the database but marked as deleted by setting the watchlist_deleted_at timestamp.
-   **Authentication**: Required.
-   **URL Parameters**: `id` (integer, required): The ID of the `user_movie` entry to update
-   **Request Body**: None (DELETE method does not have a request body)

-   **Success Response** (204 No Content): No response body.

-   **Error Responses**:
    -   `401 Unauthorized`: Not authenticated.
    -   `404 Not found`:
        - `user_movie` with given `id` does not exist
        - `user_movie` belongs to a different user (filtered out by queryset)
        - `user_movie` is already soft-deleted

**Business Logic**:
- Soft Delete: Record is NOT physically deleted from the database
- Operation: Set `watchlist_deleted_at = NOW()`
- Preservation: All other fields are preserved
- Visibility: Soft-deleted items are excluded from `GET /api/user-movies/?status=watchlist` queries
- Restoration: Soft-deleted movie can be restored by adding it again via `POST /api/user-movies/` (auto-restore logic)
- Idempotency: Second DELETE of the same ID returns `404 Not Found` (item already excluded from queryset)

**Security**:
- Authorization: User can only delete their own `user_movie` entries
- IDOR Protection: `get_queryset()` filters by `request.user`, ensuring users cannot access other user's entries
- Permission Class: `IsOwner` permission checks `obj.user == request.user` before allowing deletion
- Authorization enforced at Django application layer via ORM filters (RLS disabled for user_movie table)
</route_api_specification>

1. Related database resources:
<related_db_resources>
### Table: `user_movie`
Primary table for this endpoint.

| Column | Data Type | Constraints | Description | DELETE Behavior |
|---|---|---|---|---|
| `id` | `bigint` | **Primary Key**, Identity | Unique identifier for the interaction | Used for lookup - from URL parameter |
| `user_id` | `uuid` | **Foreign Key** -> `auth.users(id)` ON DELETE CASCADE, Not Null | The user associated with this interaction | Authorization check - must equal request.user.id |
| `tconst` | `text` | **Foreign Key** -> `movie(tconst)` ON DELETE CASCADE, Not Null | The movie associated with this interaction | Immutable - not changed |
| `watchlisted_at` | `timestamptz` | | Timestamp when the movie was added to the watchlist | Immutable - not changed |
| `watchlist_deleted_at` | `timestamptz` | | Timestamp for soft-deleting from the watchlist | Modified - Set to NOW() |
| `watched_at` | `timestamptz` | | Timestamp when the user marked the movie as watched | Immutable - not changed |
| `added_from_ai_suggestion` | `boolean` | Not Null, `default false` | Flag indicating if it was added from an AI suggestion | Immutable - not changed |

**Operation UPDATE (NOT DELETE)**:
- **Soft delete query**
    ```SQL
    UPDATE user_movie
    SET watchlist_deleted_at = NOW()
    WHERE id = 101 AND user_id = %user_id%;
    ```
    Record remains in database but marked as deleted
    Rows affect: 1 (if successful), 0 (if already deleted or wrong user)
- **Authorization query (implicit via `get_object())**
    ```SQL
    SELECT id, user_id, tconst, watchlist_deleted_at
    FROM user_movie
    WHERE id = 101 
    AND user_id = %user_id%
    AND watchlist_deleted_at IS NULL;  -- Exclude already soft-deleted
    ```
- If not found -> 404 Not Found
- Important: `get_queryset()` must filter `watchlist_deleted_at` IS NULL to exclude soft-deleted items

- **QuerySet Configuration (CRITICAL for DELETE)**
  ViewSet get_queryset() must exclude soft-deleted items:
  ```python
  def get_queryset(self):
    """
    Always filter by authenticated user AND exclude soft-deleted items.
    This ensures:
    1. Users only see their own data
    2. Soft-deleted items return 404 on second DELETE
    3. Soft-deleted items don't appear in GET requests
    """
    return UserMovie.objects.filter(
        user=self.request.user,
        watchlist_deleted_at__isnull=True  # CRITICAL!
    )
    ```

Impact on DELETE:
- First DELETE: Item found in queryset → soft delete → 204 No Content
- Second DELETE: Item NOT found in queryset (filtered out) → 404 Not Found
- This provides pseudo-idempotency (safe to retry, but not truly idempotent)

### Relationships:
- None

Database Performance Considerations:
Query Count: 2 queries total
1. Fetch & Authorization: Get `user_movie` for authorization check (1 query)
2. Soft Delete: Update `watchlist_deleted_at` (1 query)
No additional queries needed for DELETE because:
- no response body (204 No content)
- No validation of related data required
- No complex business logic

Optimization:
```SQL
# Efficient soft delete
user_movie = self.get_object()  # 1 query with authorization
user_movie.watchlist_deleted_at = timezone.now()
user_movie.save(update_fields=['watchlist_deleted_at'])  # 1 query, only updates 1 field
```

Indexes Used:
- Primary key lookup on user_movie.id (very fast)
- Partial index: (user_id) WHERE watchlist_deleted_at IS NULL (for queryset filtering)

Database Space:
- Soft-deleted records remain in database → accumulate over time
- Cleanup Strategy (optional, for future):
  ```SQL
    -- Purge soft-deleted records older than 90 days
  DELETE FROM user_movie
  WHERE watchlist_deleted_at < NOW() - INTERVAL '90 days';
  ```
</related_db_resources>

3. Definicje typów:
<type_definitions>
TypeScript types are defined in `myVOD/frontend/myVOD/src/types/api.types.ts`
</type_definitions>

4. Tech stack:
<tech_stack>
`.ai/tech-stack.md`.
</tech_stack>

5. Implementation rules:
<implementation_rules>
@shared.mdc
@backend.mdc
@django.mdc
@coding-practices.mdc
</implementation_rules>

Twoim zadaniem jest stworzenie kompleksowego planu wdrożenia endpointu `DELETE /api/user-movies/`. Przed dostarczeniem ostatecznego planu użyj znaczników <analysis>, aby przeanalizować informacje i nakreślić swoje podejście. W tej analizie upewnij się, że:

1. Podsumuj kluczowe punkty specyfikacji API.
2. Wymień wymagane i opcjonalne parametry ze specyfikacji API.
3. Wymień niezbędne typy DTO i Command Modele.
4. Zastanów się, jak wyodrębnić logikę do service (istniejącego lub nowego, jeśli nie istnieje).
5. Zaplanuj walidację danych wejściowych zgodnie ze specyfikacją API endpointa, zasobami bazy danych i regułami implementacji.
6. Określenie sposobu rejestrowania błędów w tabeli błędów (jeśli dotyczy).
7. Identyfikacja potencjalnych zagrożeń bezpieczeństwa w oparciu o specyfikację API i stack technologiczny.
8. Nakreśl potencjalne scenariusze błędów i odpowiadające im kody stanu.

Po przeprowadzeniu analizy utwórz szczegółowy plan wdrożenia w formacie markdown. Plan powinien zawierać następujące sekcje:

1. Przegląd punktu końcowego
2. Szczegóły żądania
3. Szczegóły odpowiedzi
4. Przepływ danych
5. Względy bezpieczeństwa
6. Obsługa błędów
7. Wydajność
8. Kroki implementacji

W całym planie upewnij się, że
- Używać prawidłowych kodów stanu API:
  - 200 dla pomyślnego odczytu
  - 201 dla pomyślnego utworzenia
  - 400 dla nieprawidłowych danych wejściowych
  - 401 dla braku autentykacji (Unauthorized)
  - 403 dla braku uprawnień (Forbidden) - authenticated ale no permission
  - 404 dla nie znalezionych zasobów
  - 500 dla błędów po stronie serwera
- Dostosowanie do dostarczonego stacku technologicznego
- Postępuj zgodnie z podanymi zasadami implementacji
- Zapewniasz ochronę przed N+1 queries (używaj select_related, prefetch_related)
- Implementujesz autoryzację na poziomie aplikacji Django (filtrowanie po request.user w ORM)
- RLS jest wyłączone dla user-owned tables (migracja 20251015120000_disable_rls_for_django_auth.sql)
- Uwzględniasz wszystkie edge cases (pusta lista, invalid parameters, etc.)

Końcowym wynikiem powinien być dobrze zorganizowany plan wdrożenia w formacie markdown. Oto przykład tego, jak powinny wyglądać dane wyjściowe:

``markdown
# API Endpoint Implementation Plan: [Nazwa punktu końcowego]

## 1. Przegląd punktu końcowego
[Krótki opis celu i funkcjonalności punktu końcowego]

## 2. Szczegóły żądania
- Metoda HTTP: [GET/POST/PATCH/DELETE]
- Struktura URL: [wzorzec URL]
- Parametry:
  - Wymagane: [Lista wymaganych parametrów]
  - Opcjonalne: [Lista opcjonalnych parametrów]
- Request Body: [Struktura treści żądania, jeśli dotyczy]

## 3. Wykorzystywane typy
[DTOs i Command Modele niezbędne do implementacji]

## 3. Szczegóły odpowiedzi
[Oczekiwana struktura odpowiedzi i kody statusu]

## 4. Przepływ danych
[Opis przepływu danych, w tym interakcji z zewnętrznymi usługami lub bazami danych]

## 5. Względy bezpieczeństwa
[Szczegóły uwierzytelniania, autoryzacji i walidacji danych]

## 6. Obsługa błędów
[Lista potencjalnych błędów i sposób ich obsługi]

## 7. Rozważania dotyczące wydajności
[Potencjalne wąskie gardła i strategie optymalizacji]

## 8. Etapy wdrożenia
1. [Krok 1 z szczegółami]
2. [Krok 2 z szczegółami]
3. [Krok 3 z szczegółami]

## 10. Uwagi dotyczące pozostałych metod
[Jak ten endpoint współpracuje z POST, PATCH, DELETE]
...
```
Końcowe wyniki powinny składać się wyłącznie z planu wdrożenia w formacie markdown i nie powinny powielać ani powtarzać żadnej pracy wykonanej w sekcji analizy.

Pamiętaj, aby zapisać swój plan wdrożenia jako .ai/view-implementation-plan.md. Upewnij się, że plan jest szczegółowy, przejrzysty i zapewnia kompleksowe wskazówki dla zespołu programistów.
```