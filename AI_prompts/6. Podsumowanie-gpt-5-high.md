<conversation_summary>
<decisions>
1. Tabela `users` (Supabase auth) przechowuje dane użytkowników. Kolumna `country_code` usunięta w MVP (region 'PL' globalnie).
2. Autentykacja: JWT, bez przechowywania tokenów w DB.
3. Platformy VOD: słownik `platform` + łącznik `user_platform(user_id, platform_id)` z unikatowością pary; bez wersjonowania historii wyborów platform.
4. Mapowanie platform na zewnętrzne ID: w kodzie Django (settings/constants), nie w DB.
5. `movie`: naturalny PK `tconst TEXT`; pola: `primary_title`, `original_title (opcjonalnie)`, `start_year SMALLINT`, `genres TEXT[]`, `avg_rating NUMERIC(3,1)`, `num_votes INT`, `poster_path TEXT`, `poster_last_checked TIMESTAMPTZ`, `tmdb_id BIGINT NULL`, `watchmode_id BIGINT NULL`, `created_at/updated_at`; unikatowe indeksy częściowe na `tmdb_id` i `watchmode_id`.
6. Zewnętrzne ID przeniesione do `movie` (bez tabeli `movie_external_ids`); unikatowe indeksy częściowe na każdym ID.
7. Relacje użytkownik–film: `user_movie(id, user_id, tconst, watchlisted_at, watchlist_deleted_at, watched_at, added_from_ai_suggestion BOOLEAN)`; unikalność `(user_id, tconst)`; aktywna watchlista to `watchlist_deleted_at IS NULL`.
8. Brak osobnej tabeli `watched_item` (zastąpiona przez `user_movie`).
9. Brak wzajemnego wykluczenia: stany w `user_movie` (watchlista/obejrzane) mogą współistnieć.
10. Dostępność VOD: `movie_availability(tconst, platform_id, is_available BOOLEAN NULL, last_checked, source, details JSONB)` z PK `(tconst, platform_id)`; region w MVP domyślnie 'PL' (bez kolumny `region_code`).
11. Przechowujemy szczegóły Watchmode (np. `watchmode_source_id`, `deep_link_url`) w `details JSONB`.
12. Proces odświeżania: logowany do `event` (`event_type='availability_refresh'`, properties m.in. `status`, `movies_updated`); brak osobnej tabeli.
13. Sugestie AI: `ai_suggestion_batch(id, user_id, generated_at, expires_at, prompt TEXT, response JSONB)`; limit 1/24h egzekwowany po stronie aplikacji (bez constraintu EXCLUDE).
14. Analytics: `event(id, user_id NULL, event_type, occurred_at, properties JSONB)` partycjonowane miesięcznie; wyszukiwania jako event_type='search' z properties: {query, results_count}.
15. Logi integracji: `integration_error_log(id, api_type, error_message, error_details JSONB, user_id, occurred_at)` partycjonowane miesięcznie, widoczne tylko dla admina.
16. RLS: owner-only dla danych użytkownika (`user_movie`, `user_platform`, `ai_suggestion_batch`, wiersze `event` z `user_id IS NOT NULL`); `integration_error_log` tylko dla roli admin/system; tabele globalne (`movie`, `platform`, `movie_availability`) tylko read dla ról nie‑serwisowych.
17. Dostęp do DB wyłącznie przez backend; backend używa roli respektującej RLS (nie `service_role`).
18. Rozszerzenia: `unaccent`, `pg_trgm` (wyszukiwanie).
19. Indeksy: GIN `pg_trgm` na `unaccent(lower(primary_title))`, BTREE na `start_year`; partial na `user_movie` (aktywna watchlista i obejrzane); GIN na `genres` tylko jeśli filtrujesz po gatunkach w MVP.
20. Partycjonowanie: `event`, `integration_error_log` po miesiącach (2 tabele zamiast 3).
21. Import IMDb: z `title.basics.tsv` i `title.ratings.tsv`; staging → upsert; zakres tylko `titleType='movie'`.
22. RODO: FK `ON DELETE CASCADE` z `users` do tabel właścicielskich; usuwanie konta przez Admin API (Supabase Auth), a funkcja transakcyjna czyści dane aplikacji w `public`.
23. Brak pola `movie.is_active` (nie używamy w MVP).
24. Brak progu `num_votes` dla prezentacji ocen (logika po stronie aplikacji).
25. Brak `popularity_score` w `movie` (MVP).
26. Brak DB CHECK dla `watched_at <= now()` (walidacja po stronie aplikacji).
27. **MVP uproszczenia**: połączenie `watchlist_item` i `watched_item` → `user_movie`; usunięcie `movie_external_ids`, `ai_suggestion_item`, `availability_refresh_run`; brak osobnych tabel `movie_assets`, `country`, `region_map`, `platform_external`, `search_query`; brak `analytics_daily_snapshot` i `mv_movies_in_use` (odłożone na v1.1).
</decisions>

<matched_recommendations>
1. Naturalny PK `tconst` w `movie` dla prostych integracji (IMDb/TMDB/Watchmode).
2. Konsolidacja statusów użytkownika w `user_movie` (watchlista i obejrzane) + unikalność `(user_id, tconst)`; partial indeksy na aktywną watchlistę i obejrzane.
3. Tri-stan `is_available` (TRUE/FALSE/NULL) w `movie_availability` + PK `(tconst, platform_id)` i partial indeksy na dostępne rekordy; region 'PL' w MVP.
4. Limit 24h dla `ai_suggestion_batch` egzekwowany w aplikacji (bez EXCLUDE i bez `btree_gist`).
5. GIN `pg_trgm` na `unaccent(lower(primary_title))` dla szybkiego autocomplete.
6. Partycjonowanie miesięczne logów (`event`, `integration_error_log`) + polityki retencji.
7. Rozszerzenia minimalne: `unaccent`, `pg_trgm` (bez `btree_gist`, `citext` i `uuid-ossp` w MVP).
8. ETL IMDb przez tabele staging i transakcyjny upsert (stabilność importu).
9. RLS owner-only dla danych użytkownika; `integration_error_log` admin-only; tabele referencyjne tylko read; backend używa roli respektującej RLS.
10. Zewnętrzne ID w `movie` z unikatowymi indeksami częściowymi `WHERE ... IS NOT NULL`.
11. JSONB `details/response` bez GIN w MVP (filtrowanie po stronie aplikacji).
12. Hard delete (RODO): usuwanie użytkownika przez Admin API + kaskady w danych aplikacji.
13. **MVP uproszczenia**: denormalizacja `poster_path` w `movie`, region 'PL' w logice, mapowania platform w kodzie, konsolidacja search do `event`, logowanie refreshów jako `event`.
</matched_recommendations>

<database_planning_summary>
a. Główne wymagania schematu:
- Import i wyszukiwanie filmów (IMDb), przechowywanie ocen, gatunków i plakatów, szybkie autocomplete.
- Watchlista z soft delete; równoległa ewidencja obejrzanych.
- Globalna dostępność VOD (Watchmode) po filmie/platformie/regionie z tri-stanem i timestampem; MVP tylko region 'PL'.
- Sugestie AI z cache 24h i możliwością dodania do watchlisty.
 - Profil użytkownika (platformy VOD) oraz podstawowe analytics i logowanie błędów.

b. Kluczowe encje i relacje (MVP uproszczone):
- `users` 1:N `user_movie`, `event`, `ai_suggestion_batch`.
- `movie` (PK `tconst`, zawiera `poster_path`; zewnętrzne ID w tej tabeli) 1:N `movie_availability`.
- `platform` N:M z `users` przez `user_platform`; `platform` N:M z `movie` przez `movie_availability`.
- Brak `ai_suggestion_item` (zastąpione przez `response JSONB` w `ai_suggestion_batch`).
- Brak tabeli `availability_refresh_run` (refreshy logujemy jako `event`).
- Brak osobnych tabel: `movie_assets`, `country`, `region_map`, `platform_external`, `search_query`, `analytics_daily_snapshot`, `mv_movies_in_use`.

c. Bezpieczeństwo i skalowalność:
- RLS owner-only dla danych użytkownika; logi integracji dostępne tylko dla adminów.
- Dostęp do bazy wyłącznie przez backend; RLS jako dodatkowa ochrona.
- Partycjonowanie 2 tabel logów (`event`, `integration_error_log`) + indeksy częściowe/kompozytowe dla krytycznych ścieżek (watchlista, dostępność).
 - Rozszerzenia `pg_trgm`, `unaccent` dla skalowalnego wyszukiwania.
- ETL z stagingiem dla IMDb.
- Mapowania platform na zewnętrzne ID w kodzie Django (nie w DB).

d. MVP parametry operacyjne:
- Retencja danych: `event` 90 dni, `integration_error_log` 90 dni, `ai_suggestion_batch` 30 dni po `expires_at`.
- Region: hardcodowany 'PL' w logice aplikacji; bez kolumny `region_code` w `movie_availability`.
- Platformy: netflix, hbomax, disneyplus, primevideo, appletvplus.
- JSONB bez indeksów GIN (filtrowanie po stronie aplikacji).
- Analytics on-demand z tabel event/users (bez snapshotów).
- Odświeżanie dostępności: piątki 18:00 Europe/Warsaw.
</database_planning_summary>

<unresolved_issues>
1. ✅ **ROZSTRZYGNIĘTE**: Retencja danych dla MVP.
   - `event`: 90 dni (partycje miesięczne).
   - `integration_error_log`: 90 dni (partycje miesięczne).
   - `ai_suggestion_batch/item`: 30 dni po `expires_at` (hard delete).
   - Implementacja: codzienny job 02:30 UTC (drop starych partycji).

2. ✅ **ROZSTRZYGNIĘTE**: Lista platform VOD dla MVP.
   - netflix ("Netflix"), hbomax ("HBO Max"), disneyplus ("Disney+"), primevideo ("Prime Video"), appletvplus ("Apple TV+").
   - **Uproszczenie**: mapowania na zewnętrzne ID (Watchmode, TMDB) w kodzie Django (settings/constants), nie w tabeli `platform_external`.

3. ✅ **ROZSTRZYGNIĘTE**: Wyszukiwanie tekstowe dla MVP.
   - Włączyć rozszerzenia: `unaccent` + `pg_trgm`.
   - Indeks GIN na `unaccent(lower(primary_title))`.
   - FTS (Full Text Search) odłożone na v1.1.

4. ✅ **ROZSTRZYGNIĘTE**: Region i dostępność dla MVP.
   - **Uproszczenie**: region hardcodowany 'PL' w logice (bez kolumny `region_code` w `movie_availability`).
   - Usunięte tabele: `country`, `region_map`.
   - Job dostępności: piątki 18:00 Europe/Warsaw, log do `event` (`event_type='availability_refresh'`).

5. ✅ **ROZSTRZYGNIĘTE**: Indeksy JSONB dla MVP.
   - **Uproszczenie**: brak indeksów GIN na JSONB (`details`, `response`).
   - Filtrowanie po stronie aplikacji.
   - Jeśli potrzebne w przyszłości: indeksy wyrażenia na konkretne klucze lub migracja do kolumn relacyjnych.

6. ✅ **ROZSTRZYGNIĘTE**: Analytics dla MVP.
   - **Uproszczenie**: brak `analytics_daily_snapshot` i `mv_movies_in_use`.
   - Metryki liczone on-demand z tabel `event`, `users`, `user_movie`.
   - Snapshoty i materializowane widoki odłożone na v1.1 (gdy pojawi się potrzeba optymalizacji).

7. ✅ **ROZSTRZYGNIĘTE**: Logowanie wyszukiwań dla MVP.
   - **Uproszczenie**: brak osobnej tabeli `search_query`.
   - Wyszukiwania jako `event` z `event_type='search'` i `properties: {query, results_count}`.
   - Partycjonowanie miesięczne razem z innymi eventami.

8. ✅ **ROZSTRZYGNIĘTE**: Plakaty filmów dla MVP.
   - **Uproszczenie**: brak osobnej tabeli `movie_assets`.
   - Pola `poster_path` i `poster_last_checked` bezpośrednio w tabeli `movie`.
   - Denormalizacja uzasadniona relacją 1:1 i uproszczeniem query.

9. ✅ **ROZSTRZYGNIĘTE**: Logowanie refreshów dostępności.
   - **Uproszczenie**: brak osobnej tabeli; logujemy do `event` z `event_type='availability_refresh'` i `properties` zawierającymi m.in. `status` oraz `movies_updated`.


</conversation_summary>