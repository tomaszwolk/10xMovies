<conversation_summary>
<decisions>
1. Tabela `users` (Supabase auth) przechowuje dane użytkowników, w tym `country_code` (domyślnie `PL`).
2. Autentykacja: JWT, bez przechowywania tokenów w DB.
3. Platformy VOD: słownik `platform` + łącznik `user_platform(user_id, platform_id)` z unikatowością pary; bez wersjonowania historii wyborów platform.
4. Mapowanie platform na zewnętrzne ID: w kodzie Django (settings/constants), nie w DB.
5. `movie`: naturalny PK `tconst TEXT`; pola: `title_type='movie'`, `primary_title`, `original_title (opcjonalnie)`, `start_year SMALLINT`, `genres TEXT[]`, `avg_rating NUMERIC(3,1)`, `num_votes INT`, `poster_path TEXT`, `poster_last_checked TIMESTAMPTZ`, `created_at/updated_at`.
6. Zewnętrzne ID: `movie_external_ids(tconst PK, tmdb_id BIGINT NULL, watchmode_id BIGINT NULL)` z unikatowością indeksów częściowych na każdym ID.
7. Watchlista: `watchlist_item(id, user_id, tconst, added_at, deleted_at, added_from_ai_suggestion BOOLEAN)`; constraint: partial UNIQUE `(user_id, tconst) WHERE deleted_at IS NULL`.
8. Obejrzane: `watched_item(id, user_id, tconst, watched_at)` z unikatowością `(user_id, tconst)`.
9. Brak wzajemnego wykluczenia: film może równocześnie występować w `watchlist_item` i `watched_item`.
10. Dostępność VOD: globalnie w `movie_availability(tconst, platform_id, region_code, is_available BOOLEAN NULL, last_checked, source, details JSONB)` z PK `(tconst, platform_id, region_code)`; region_code hardcodowany 'PL' w MVP (CHECK constraint).
11. Przechowujemy szczegóły Watchmode (np. `watchmode_source_id`, `deep_link_url`) w `details JSONB`.
12. Proces odświeżania: `availability_refresh_run(started_at, completed_at, status, movies_updated)` - uproszczone logowanie runów.
13. Sugestie AI: `ai_suggestion_batch(id, user_id, generated_at, expires_at, prompt TEXT, response JSONB)` + `ai_suggestion_item(id, batch_id, suggested_title, year, reason, tmdb_id/tconst NULL)`; limit 1/24h przez EXCLUDE (GiST + tstzrange).
14. Analytics: `event(id, user_id NULL, event_type, occurred_at, properties JSONB)` partycjonowane miesięcznie; wyszukiwania jako event_type='search' z properties: {query, results_count}.
15. Logi integracji: `integration_error_log(id, api_type, error_message, error_details JSONB, user_id, occurred_at)` partycjonowane miesięcznie, widoczne tylko dla admina.
16. RLS: włączone dla tabel właścicielskich (`watchlist_item`, `watched_item`, `user_platform`, `ai_*`, `event`, `integration_error_log`) z polityką owner-only; tabele globalne (`movie`, `platform`, `movie_availability`, `movie_external_ids`) tylko read dla ról nie-serwisowych.
17. Dostęp do DB wyłącznie przez backend Django (rola serwisowa); RLS jako dodatkowa warstwa ochrony.
18. Rozszerzenia: `pg_trgm`, `btree_gist`, `citext`, `unaccent` (wyszukiwanie), opcjonalnie `uuid-ossp`.
19. Indeksy: GIN `pg_trgm` na `unaccent(lower(primary_title))`, BTREE na `start_year`, kompozyty i partiale na dostępność/aktywne pozycje, GIN na `genres`.
20. Partycjonowanie: `event`, `integration_error_log` po miesiącach (2 tabele zamiast 3).
21. Import IMDb: z `title.basics.tsv` i `title.ratings.tsv`; staging → upsert; zakres tylko `titleType='movie'`.
22. RODO: FK `ON DELETE CASCADE` z `users` do tabel właścicielskich; transakcyjna funkcja `SECURITY DEFINER` do hard delete.
23. Brak pola `movie.is_active` (nie używamy w MVP).
24. Brak progu `num_votes` dla prezentacji ocen (logika po stronie aplikacji).
25. Brak `popularity_score` w `movie` (MVP).
26. Brak DB CHECK dla `watched_at <= now()` (walidacja po stronie aplikacji).
27. **MVP uproszczenia**: brak osobnych tabel `movie_assets`, `country`, `region_map`, `platform_external`, `search_query`; brak `analytics_daily_snapshot` i `mv_movies_in_use` (odłożone na v1.1).
</decisions>

<matched_recommendations>
1. Naturalny PK `tconst` w `movie` dla prostych integracji (IMDb/TMDB/Watchmode).
2. Soft delete w `watchlist_item` + partial UNIQUE.
3. Tri-stan `is_available` (TRUE/FALSE/NULL) w `movie_availability` + kompozytowy PK i partial indeksy na dostępne rekordy.
4. EXCLUDE (GiST) na oknach czasowych w `ai_suggestion_batch` do limitu 24h.
5. GIN `pg_trgm` na `unaccent(lower(primary_title))` dla szybkiego autocomplete.
6. Partycjonowanie miesięczne logów (`event`, `integration_error_log`) + polityki retencji.
7. Rozszerzenia: `pg_trgm`, `btree_gist`, `citext`, `unaccent` dla jakości wyszukiwania i constraintów czasowych.
8. ETL IMDb przez tabele staging i transakcyjny upsert (stabilność importu).
9. RLS owner-only dla tabel użytkownika; tabele referencyjne tylko read; dostęp wyłącznie przez backend (rola serwisowa bez BYPASSRLS).
10. Indeksy pokrywające użyte sortowania/filtry: `watchlist_item(user_id, deleted_at, added_at DESC)` (partial), `watched_item(user_id, watched_at DESC)`.
11. Zewnętrzne ID z unikatowymi indeksami częściowymi `WHERE ... IS NOT NULL`.
12. JSONB `details/response` bez GIN w MVP (filtrowanie po stronie aplikacji).
13. Hard delete (RODO) przez dedykowaną funkcję transakcyjną + kaskady FK.
14. **MVP uproszczenia**: denormalizacja poster_path do `movie`, hardcodowanie 'PL', mapowania platform w kodzie, konsolidacja search do `event`, uproszczenie logowania refresh runów.
</matched_recommendations>

<database_planning_summary>
a. Główne wymagania schematu:
- Import i wyszukiwanie filmów (IMDb), przechowywanie ocen, gatunków i plakatów, szybkie autocomplete.
- Watchlista z soft delete; równoległa ewidencja obejrzanych.
- Globalna dostępność VOD (Watchmode) po filmie/platformie/regionie z tri-stanem i timestampem; MVP tylko region 'PL'.
- Sugestie AI z cache 24h i możliwością dodania do watchlisty.
- Profil użytkownika (platformy VOD, kraj) oraz podstawowe analytics i logowanie błędów.

b. Kluczowe encje i relacje (MVP uproszczone):
- `users` 1:N `watchlist_item`, `watched_item`, `event`, `ai_suggestion_batch`.
- `movie` (PK `tconst`, zawiera poster_path) 1:1 `movie_external_ids`, 1:N `movie_availability`.
- `platform` N:M z `users` przez `user_platform`; `platform` N:M z `movie` przez `movie_availability`.
- `ai_suggestion_batch` 1:N `ai_suggestion_item`.
- `availability_refresh_run` (uproszczone logowanie).
- Brak osobnych tabel: `movie_assets`, `country`, `region_map`, `platform_external`, `search_query`, `analytics_daily_snapshot`, `mv_movies_in_use`.

c. Bezpieczeństwo i skalowalność:
- RLS owner-only dla danych użytkownika; logi integracji dostępne tylko dla adminów.
- Dostęp do bazy wyłącznie przez backend; RLS jako dodatkowa ochrona.
- Partycjonowanie 2 tabel logów (`event`, `integration_error_log`) + indeksy częściowe/kompozytowe dla krytycznych ścieżek (watchlista, dostępność).
- Rozszerzenia `pg_trgm`, `unaccent` dla skalowalnego wyszukiwania; `btree_gist` dla constraintów czasowych; `citext` dla unikalności emaili.
- ETL z stagingiem dla IMDb.
- Mapowania platform na zewnętrzne ID w kodzie Django (nie w DB).

d. MVP parametry operacyjne:
- Retencja danych: `event` 90 dni, `integration_error_log` 90 dni, `ai_suggestion_batch` 30 dni po `expires_at`.
- Region: hardcodowany 'PL' (CHECK constraint w `movie_availability.region_code`).
- Platformy: netflix, hbomax, disneyplus, primevideo, appletvplus.
- JSONB bez indeksów GIN (filtrowanie po stronie aplikacji).
- Analytics on-demand z tabel event/users (bez snapshotów).
- Odświeżanie dostępności: piątki 18:00 Europe/Warsaw.
</database_planning_summary>

<unresolved_issues>
1. ✅ **ROZSTRZYGNIĘTE**: Retencja danych dla MVP.
   - `event`: 90 dni (partycje miesięczne).
   - `integration_error_log`: 90 dni (partycje miesięczne).
   - `ai_suggestion_batch/item`: 30 dni po `expires_at` (hard delete).
   - Implementacja: codzienny job 02:30 UTC (drop starych partycji).

2. ✅ **ROZSTRZYGNIĘTE**: Lista platform VOD dla MVP.
   - netflix ("Netflix"), hbomax ("HBO Max"), disneyplus ("Disney+"), primevideo ("Prime Video"), appletvplus ("Apple TV+").
   - **Uproszczenie**: mapowania na zewnętrzne ID (Watchmode, TMDB) w kodzie Django (settings/constants), nie w tabeli `platform_external`.

3. ✅ **ROZSTRZYGNIĘTE**: Wyszukiwanie tekstowe dla MVP.
   - Włączyć rozszerzenia: `unaccent` + `pg_trgm`.
   - Indeks GIN na `unaccent(lower(primary_title))`.
   - FTS (Full Text Search) odłożone na v1.1.

4. ✅ **ROZSTRZYGNIĘTE**: Region i dostępność dla MVP.
   - **Uproszczenie**: region hardcodowany 'PL' w `movie_availability` (CHECK constraint).
   - Usunięte tabele: `country`, `region_map`.
   - Job dostępności: piątki 18:00 Europe/Warsaw, log do `availability_refresh_run`.

5. ✅ **ROZSTRZYGNIĘTE**: Indeksy JSONB dla MVP.
   - **Uproszczenie**: brak indeksów GIN na JSONB (`details`, `response`).
   - Filtrowanie po stronie aplikacji.
   - Jeśli potrzebne w przyszłości: indeksy wyrażenia na konkretne klucze lub migracja do kolumn relacyjnych.

6. ✅ **ROZSTRZYGNIĘTE**: Analytics dla MVP.
   - **Uproszczenie**: brak `analytics_daily_snapshot` i `mv_movies_in_use`.
   - Metryki liczone on-demand z tabel `event`, `users`, `watchlist_item`.
   - Snapshoty i materializowane widoki odłożone na v1.1 (gdy pojawi się potrzeba optymalizacji).

7. ✅ **ROZSTRZYGNIĘTE**: Logowanie wyszukiwań dla MVP.
   - **Uproszczenie**: brak osobnej tabeli `search_query`.
   - Wyszukiwania jako `event` z `event_type='search'` i `properties: {query, results_count}`.
   - Partycjonowanie miesięczne razem z innymi eventami.

8. ✅ **ROZSTRZYGNIĘTE**: Plakaty filmów dla MVP.
   - **Uproszczenie**: brak osobnej tabeli `movie_assets`.
   - Pola `poster_path` i `poster_last_checked` bezpośrednio w tabeli `movie`.
   - Denormalizacja uzasadniona relacją 1:1 i uproszczeniem query.

9. ✅ **ROZSTRZYGNIĘTE**: Logowanie refresh runów dla MVP.
   - **Uproszczenie**: tabela `availability_refresh_run` z podstawowymi polami:
     - `started_at`, `completed_at`, `status`, `movies_updated`.
   - Usunięte pola: `movies_checked`, `errors_count`, `error_message` (szczegóły w `integration_error_log`).

---

### Podsumowanie uproszczeń MVP:

**Usunięte tabele (7):**
- `movie_assets` → denormalizacja do `movie`
- `country` → hardcodowany 'PL'
- `region_map` → hardcodowany 'PL'
- `platform_external` → mapowania w kodzie
- `search_query` → konsolidacja do `event`
- `analytics_daily_snapshot` → odłożone na v1.1
- `mv_movies_in_use` → odłożone na v1.1

**Uproszczone tabele (1):**
- `availability_refresh_run` → mniej metryk

**Korzyści:**
- **11 tabel głównych** (było 15) + 3 staging = 14 tabel
- **2 tabele partycjonowane** (było 3): `event`, `integration_error_log`
- Szybszy development, prostszy maintenance, mniej JOIN-ów
- Zachowana możliwość rozbudowy w v1.1 gdy pojawi się rzeczywista potrzeba


</conversation_summary>