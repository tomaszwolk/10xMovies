Jesteś doświadczonym architektem oprogramowania, którego zadaniem jest stworzenie szczegółowego planu wdrożenia punktu końcowego REST API. Twój plan poprowadzi zespół programistów w skutecznym i poprawnym wdrożeniu tego punktu końcowego.

Zanim zaczniemy, zapoznaj się z poniższymi informacjami:

1. Route API specification:
<route_api_specification>
#### `PATCH /api/user-movies/<id>/`

-   **Description**: Updates a user-movie entry. Used to move a movie to "watched", restore it to the watchlist.
-   **Authentication**: Required.
-   **URL Parameters**: `id` (integer, required): The ID of the `user_movie` entry to update
-   **Request Body** (to mark as watched):
    ```json
    {
      "action": "mark_as_watched"
    }
    ```

-   **Request Body** (to restore to watchlist):
    ```json
    {
      "action": "restore_to_watchlist"
    }
    ```

-   **Success Response** (200 OK): Returns the updated `user-movie` object.
   - for `mark_as_watched`:
    ```json
    {
    "id": 101,
    "movie": {
      "tconst": "tt0816692",
      "primary_title": "Interstellar",
      "start_year": 2014,
      "genres": ["Adventure", "Drama", "Sci-Fi"],
      "avg_rating": "8.6",
      "poster_path": "https://image.tmdb.org/t/p/w500/gEU2QniE6E77NI6lCU6MxlNBvIx.jpg"
    },
    "availability": [
      {"platform_id": 1, "platform_name": "Netflix", "is_available": true}
    ],
    "watchlisted_at": "2025-10-12T10:00:00Z",
    "watched_at": "2025-10-12T18:45:00Z"
    }
    ```
  - for `restore_to_watchlist`:
    ```json
    {
    "id": 101,
    "movie": { ... },
    "availability": [ ... ],
    "watchlisted_at": "2025-10-12T10:00:00Z",
    "watched_at": null
    }
    ```

-   **Error Responses**:
    -   `400 Bad Request`:
        - Missing `action` field in request body
        - Invalid `action` value (not `mark_as_watched` or `restore_to_watchlist`)
        - Business logic violation:
          - Attempting to `mark_as_watched` a movie that is already watched
          - Attempting to `restore_to_watchlist` a movie that is not watched
    -   `403 Forbidden`: Not authorized.
    -   `404 Not found`: 
        - Movie is already on the watchlist.
        - Entry not found or does not belong to

**Business Logic**:
Action: `mark_as_watched`:
    - Precondition: Movie must be on watchlist (`watchlisted_at IS NOT NULL`, `watchlist_deleted_at IS NULL`) and NOT already watched (`watched_at IS NULL`)
    - Operation: Set `watched_at = NOW()`
    - Effect: Movie moves from "watchlist" to "watched history"
    - Note: `watchlisted_at` timestamp is preserved (not cleared)
Action: `restore_to_watchlist`:
- Precondition: Movie must be marked as watched (`watched_at IS NOT NULL`)
- Operation: Set `watched_at = NULL`
- Effect: Movie moves from "watched history" back to "watchlist"
- Note: `watchlisted_at` timestamp remains unchanged
Security:
- Authorization: User can only update their own `user_movie` entries
- IDOR Protection: get_queryset() filters by `request.user`, ensuring users cannot access other users' entries
- Permission Class: IsOwner permission checks `obj.user == request.user` before allowing modification
Immutability:
- `watchlisted_at` is never modified by PATCH operations (only set once when added to watchlist)
- id, user_id, tconst are immutable (cannot be changed via PATCH)
</route_api_specification>

1. Related database resources:
<related_db_resources>
### Table: `user_movie`
Primary table for this endpoint.

| Column | Data Type | Constraints | Description | PATCH Behavior |
|---|---|---|---|---|
| `id` | `bigint` | **Primary Key**, Identity | Unique identifier for the interaction | Used for lookup - from URL parameter |
| `user_id` | `uuid` | **Foreign Key** -> `auth.users(id)` ON DELETE CASCADE, Not Null | The user associated with this interaction | Authorization check - must equal request.user.id |
| `tconst` | `text` | **Foreign Key** -> `movie(tconst)` ON DELETE CASCADE, Not Null | The movie associated with this interaction | Immutable - not changed |
| `watchlisted_at` | `timestamptz` | | Timestamp when the movie was added to the watchlist | Immutable - never modified by PATCH |
| `watchlist_deleted_at` | `timestamptz` | | Timestamp for soft-deleting from the watchlist | Not modified - stays NULL |
| `watched_at` | `timestamptz` | | Timestamp when the user marked the movie as watched | Modified - Set to NOW() or NULL depending on action |
| `added_from_ai_suggestion` | `boolean` | Not Null, `default false` | Flag indicating if it was added from an AI suggestion | Immutable - not changed |

**Constraints**:
- **Unique** (`user_id`, `tconst`) - Ensures a single interaction record per user per movie

**Operation UPDATE**:
- **mark_as_watched**
    ```SQL
    UPDATE user_movie
    SET watched_at = NOW()
    WHERE id = 101 AND user_id = %user_id%;
    ```
- **restore_to_watchlist**
    ```SQL
    UPDATE user_movie
    SET watched_at = NULL
    WHERE id = 101 AND user_id = %user_id%;
    ```
- Precondition check: `watched_at` must NOT be `NULL` before update
- Result: `watched_at` is cleared

- **Authorization query (implicit via get_object())**:
    ```SQL
    SELECT * FROM user_movie
    WHERE id = 101 AND user_id = %user_id%;
    ```
- If not found -> 404 Not found
- If found but different user -> 404 Not Found

### Table: `movie`
Used to retrieve movie details for the response.

| Column | Data Type | Constraints | Description | PATCH Usage |
|---|---|---|---|---|
| `tconst` | `text` | **Primary Key** | IMDb unique identifier for the title (e.g., "tt0111161"). | JOIN key - from user_movie.tconst |
| `primary_title`| `text` | Not Null | The primary title of the movie. | Retrieved for response |
| `original_title`| `text` | | The original title of the movie, if different. | - |
| `start_year` | `smallint` | | The release year of the movie. | Retrieved for response |
| `genres` | `text[]` | | Array of movie genres. | Retrieved for response |
| `avg_rating` | `numeric(3, 1)` | | Average user rating. | Retrieved for response |
| `num_votes` | `integer` | | Number of votes for the rating. | - |
| `poster_path` | `text` | | URL path to the movie poster (from TMDB). | Retrieved for response |
| `poster_last_checked` | `timestamptz` | | When the poster path was last checked/updated. | - |
| `tmdb_id` | `bigint` | **Unique** (partial) | The Movie Database (TMDB) ID. | - |
| `watchmode_id` | `bigint` | **Unique** (partial) | Watchmode.com ID. | - |
| `created_at` | `timestamptz` | Not Null, `default now()` | Timestamp of record creation. | - |
| `updated_at` | `timestamptz` | Not Null, `default now()` | Timestamp of last record update. | - |

**Operation SELECT (via JOIN or select_related()) for response building**:
```SQL
SELECT 
  um.id, um.watchlisted_at, um.watched_at,
  m.tconst, m.primary_title, m.start_year, m.genres, m.avg_rating, m.poster_path
FROM user_movie um
INNER JOIN movie m ON um.tconst = m.tconst
WHERE um.id = 101 AND um.user_id = %user_id%;
```
- Optimization: Use Django's select_related('movie') to fetch in single query

### Table: `movie_availability`
Used to fetch availability info to include in the response.

| Column | Data Type | Constraints | Description | PATCH Usage |
|---|---|---|---|---|
| `tconst` | `text` | **Primary Key**, **Foreign Key** -> `movie(tconst)` ON DELETE CASCADE | Movie identifier | Filter by updated movie's tconst |
| `platform_id` | `smallint` | **Primary Key**, **Foreign Key** -> `platform(id)` ON DELETE CASCADE | Platform identifier | Filter by user's selected platforms |
| `is_available` | `boolean` | | Tri-state: `true` (available), `false` (unavailable), `null` (unknown) | Return in response |
| `last_checked` | `timestamptz` | Not Null | Timestamp of the last availability check | - |
| `source` | `text` | Not Null | The source of the availability data (e.g., "watchmode") | - |
| `details` | `jsonb` | | Additional details from the source API (e.g., deep links) | - |
| `platform_name` | `text` | (JOIN from platform) | Platform name | Return in response | 

**Operation SELECT**:
```SQL
SELECT 
  ma.tconst, ma.platform_id,
  p.platform_name, ma.is_available
FROM movie_availability ma
INNER JOIN platform p ON ma.platform_id = p.id
WHERE ma.tconst = 'tt0816692'
  AND ma.platform_id IN (1, 2, 3);  -- User's selected platforms
```

### Table: `platform`
Joined with `movie_availability` to get platform names.

| Column | Data Type | Constraints | Description | PATCH Usage |
|---|---|---|---|---|
| `id` | `smallint` | **Primary Key**, Identity | Unique identifier for the platform | Used in JOIN |
| `platform_slug` | `text` | **Unique**, Not Null | URL-friendly slug (e.g., "netflix") | - |
| `platform_name` | `text` | Not Null | User-friendly name (e.g., "Netflix") | Return in availability array |

### Table: `user_platform`
Used to determine which platforms the user has selected.

| Column | Data Type | Constraints | Description | PATCH Usage |
|---|---|---|---|---|
| `user_id` | `uuid` | **Primary Key**, **Foreign Key** -> `auth.users(id)` ON DELETE CASCADE | User's identifier | Filter by request.user.id |
| `platform_id` | `smallint` | **Primary Key**, **Foreign Key** -> `platform(id)` ON DELETE CASCADE | Platform's identifier | Collect IDs for availability query |

**Operation SELECT**:
```SQL
SELECT platform_id FROM user_platform WHERE user_id = %user_id%;
```

### Relationships:
- **`user_movie` → `movie`**: Many-to-One (via `tconst`) A movie can be on many users' watchlists.
- **`user_movie` → `users`**: Many-to-One (via `user_id`) A user can have many movie interactions.
- **`movie_availability` → `movie`**: Many-to-One (via `tconst`) A movie can have availability status on multiple platforms.
- **`movie_availability` → `platform`**: Many-to-One (via `platform_id`) A platform can list many movies.
- **`user_platform` → `users`**: Many-to-One (via `user_id`) A user can have multiple platform subscriptions.
- **`user_platform` → `platform`**: Many-to-One (via `platform_id`) A platform can be subscribed to by many users.

Important Notes:
- watchlisted_at is preserved when marking as watched (we keep the original date)
- PATCH can only transition between "Watchlist" ↔ "Watched" states
- Soft-deleted items cannot be modified by PATCH (they're excluded from queryset)

Database Performance Considerations:
Query Count: 4 queries total
1. Fetch & Authorization: Get user_movie with movie (1 query with select_related)
2. Update: Modify watched_at (1 query)
3. Get user platforms: Fetch platform IDs (1 query)
4. Get availability: Fetch with platform names (1 query with JOIN)

Optimization:
```SQL
# Step 1: Efficient fetch with select_related
user_movie = UserMovie.objects.select_related('movie').get(
    id=pk,
    user=request.user
)

# Step 2: Update only the changed field
user_movie.save(update_fields=['watched_at'])

**Indexes Used**:
- Primary key lookup on user_movie.id (very fast)
- Foreign key index on user_movie.user_id (for authorization)
- Foreign key index on user_movie.tconst (for movie JOIN)
```
</related_db_resources>

3. Definicje typów:
<type_definitions>
TypeScript types are defined in `myVOD/frontend/myVOD/src/types/api.types.ts`
</type_definitions>

4. Tech stack:
<tech_stack>
`.ai/tech-stack.md`.
</tech_stack>

5. Implementation rules:
<implementation_rules>
@shared.mdc
@backend.mdc
@django.mdc
@coding-practices.mdc
</implementation_rules>

Twoim zadaniem jest stworzenie kompleksowego planu wdrożenia endpointu `GET /api/user-movies/`. Przed dostarczeniem ostatecznego planu użyj znaczników <analysis>, aby przeanalizować informacje i nakreślić swoje podejście. W tej analizie upewnij się, że:

1. Podsumuj kluczowe punkty specyfikacji API.
2. Wymień wymagane i opcjonalne parametry ze specyfikacji API.
3. Wymień niezbędne typy DTO i Command Modele.
4. Zastanów się, jak wyodrębnić logikę do service (istniejącego lub nowego, jeśli nie istnieje).
5. Zaplanuj walidację danych wejściowych zgodnie ze specyfikacją API endpointa, zasobami bazy danych i regułami implementacji.
6. Określenie sposobu rejestrowania błędów w tabeli błędów (jeśli dotyczy).
7. Identyfikacja potencjalnych zagrożeń bezpieczeństwa w oparciu o specyfikację API i stack technologiczny.
8. Nakreśl potencjalne scenariusze błędów i odpowiadające im kody stanu.

Po przeprowadzeniu analizy utwórz szczegółowy plan wdrożenia w formacie markdown. Plan powinien zawierać następujące sekcje:

1. Przegląd punktu końcowego
2. Szczegóły żądania
3. Szczegóły odpowiedzi
4. Przepływ danych
5. Względy bezpieczeństwa
6. Obsługa błędów
7. Wydajność
8. Kroki implementacji

W całym planie upewnij się, że
- Używać prawidłowych kodów stanu API:
  - 200 dla pomyślnego odczytu
  - 201 dla pomyślnego utworzenia
  - 400 dla nieprawidłowych danych wejściowych
  - 403 dla nieautoryzowanego dostępu
  - 404 dla nie znalezionych zasobów
  - 500 dla błędów po stronie serwera
- Dostosowanie do dostarczonego stacku technologicznego
- Postępuj zgodnie z podanymi zasadami implementacji
- Zapewniasz ochronę przed N+1 queries (używaj select_related, prefetch_related)
- Implementujesz Row Level Security (filtrowanie po authenticated user)
- Uwzględniasz wszystkie edge cases (pusta lista, invalid parameters, etc.)

Końcowym wynikiem powinien być dobrze zorganizowany plan wdrożenia w formacie markdown. Oto przykład tego, jak powinny wyglądać dane wyjściowe:

``markdown
# API Endpoint Implementation Plan: [Nazwa punktu końcowego]

## 1. Przegląd punktu końcowego
[Krótki opis celu i funkcjonalności punktu końcowego]

## 2. Szczegóły żądania
- Metoda HTTP: [GET/POST/PATCH/DELETE]
- Struktura URL: [wzorzec URL]
- Parametry:
  - Wymagane: [Lista wymaganych parametrów]
  - Opcjonalne: [Lista opcjonalnych parametrów]
- Request Body: [Struktura treści żądania, jeśli dotyczy]

## 3. Wykorzystywane typy
[DTOs i Command Modele niezbędne do implementacji]

## 3. Szczegóły odpowiedzi
[Oczekiwana struktura odpowiedzi i kody statusu]

## 4. Przepływ danych
[Opis przepływu danych, w tym interakcji z zewnętrznymi usługami lub bazami danych]

## 5. Względy bezpieczeństwa
[Szczegóły uwierzytelniania, autoryzacji i walidacji danych]

## 6. Obsługa błędów
[Lista potencjalnych błędów i sposób ich obsługi]

## 7. Rozważania dotyczące wydajności
[Potencjalne wąskie gardła i strategie optymalizacji]

## 8. Etapy wdrożenia
1. [Krok 1 z szczegółami]
2. [Krok 2 z szczegółami]
3. [Krok 3 z szczegółami]

## 10. Uwagi dotyczące pozostałych metod
[Jak ten endpoint współpracuje z POST, PATCH, DELETE]
...
```

Końcowe wyniki powinny składać się wyłącznie z planu wdrożenia w formacie markdown i nie powinny powielać ani powtarzać żadnej pracy wykonanej w sekcji analizy.

Pamiętaj, aby zapisać swój plan wdrożenia jako .ai/view-implementation-plan.md. Upewnij się, że plan jest szczegółowy, przejrzysty i zapewnia kompleksowe wskazówki dla zespołu programistów.