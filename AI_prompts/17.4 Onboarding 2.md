Jako starszy programista frontendu Twoim zadaniem jest stworzenie szczegółowego planu wdrożenia nowego widoku w aplikacji internetowej. Plan ten powinien być kompleksowy i wystarczająco jasny dla innego programisty frontendowego, aby mógł poprawnie i wydajnie wdrożyć widok.

Najpierw przejrzyj następujące informacje:

1. Product Requirements Document (PRD):
<prd>
@prd.md
</prd>

2. Opis widoku:
<view_description>
Widok: Onboarding – Krok 2: Dodaj 3 filmy do watchlisty
- Ścieżka widoku: `/onboarding/add`
- Główny cel: Dodanie 0–3 filmów do watchlisty poprzez wyszukiwarkę z autocomplete.
- Kluczowe informacje do wyświetlenia: pole wyszukiwania, dropdown do 10 wyników (plakat, tytuł, rok, ocena), licznik „Dodane: X/3”, lista dodanych.
- Kluczowe komponenty widoku: Combobox z debounce, Lista wyników, Lista dodanych pozycji (mini-kafelki), Buttons (Dalej, Skip).
- UX, dostępność i względy bezpieczeństwa: responsywność i łatwe trafianie w pozycje listy, placeholder dla braku plakatu, jasny komunikat przy braku wyników, zapobieganie duplikatom w sesji.
</view_description>

3. User Stories:
<user_stories>
US-005: Onboarding - Dodanie pierwszych filmów
Jako nowy użytkownik chcę dodać pierwsze 3 filmy do watchlisty, aby poznać funkcjonalność aplikacji.

Kryteria akceptacji:
- System wyświetla ekran z tytułem "Dodaj pierwsze 3 filmy do watchlisty" (Krok 2/3)
- Wyświetlana jest wyszukiwarka z autocomplete
- Licznik pokazuje postęp: "Dodane: 0/3", "1/3", "2/3", "3/3"
- Użytkownik może dodać 0-3 filmy (nie jest wymagane minimum)
- Każdy dodany film pojawia się na liście poniżej wyszukiwarki
- Przycisk "Dalej" jest aktywny po dodaniu 3 filmów lub od razu (brak wymuszenia)
- Przycisk "Skip" pozwala pominąć krok
- Po kliknięciu "Dalej" lub "Skip" użytkownik przechodzi do Kroku 3
- Dodane filmy są zapisywane na watchliście użytkownika

US-007: Pomijanie onboardingu
Jako nowy użytkownik w pośpiechu chcę pominąć onboarding, aby od razu zacząć korzystać z aplikacji.

Kryteria akceptacji:
- Każdy krok onboardingu ma widoczny przycisk "Skip"
- Kliknięcie "Skip" na Kroku 1 lub 2 przenosi do następnego kroku
- Kliknięcie "Skip" na Kroku 3 kończy onboarding i przenosi do aplikacji
- Żadne dane nie są zapisywane przy pomijaniu kroków
- Użytkownik ląduje na pustej watchliście
- Brak błędów przy pustych danych (brak platform, filmów, obejrzanych)
</user_stories>

4. Endpoint Description:
<endpoint_description>
#### `POST /api/user-movies/`

-   **Description**: Adds a new movie to the user's watchlist.
-   **Authentication**: Required.
-   **Request Body**:
    ```json
    {
      "tconst": "tt0816692"
    }
    ```

-   **Success Response** (201 Created): Returns the newly created `user-movie` object.
  ```json
  {
    "id": 102,
    "movie": {
      "tconst": "tt0816692",
      "primary_title": "Interstellar",
      "start_year": 2014,
      "genres": ["Adventure", "Drama", "Sci-Fi"],
      "avg_rating": "8.6",
      "poster_path": "https://image.tmdb.org/t/p/w500/gEU2QniE6E77NI6lCU6MxlNBvIx.jpg"
    },
    "availability": [
      {"platform_id": 1, "platform_name": "Netflix", "is_available": true},
      {"platform_id": 2, "platform_name": "HBO Max", "is_available": false}
    ],
    "watchlisted_at": "2025-10-12T14:30:00Z",
    "watched_at": null
  }
  ```
-   **Error Responses**:
    -   `400 Bad Request`:
        - Missing `tconst` field in request body
        - Movie with given `tconst` does not exist in database
        - Invalid `tconst` format
    -   `401 Unauthorized`: Not authenticated.
    -   `409 Conflict`: Movie is already on the watchlist.
Endpoint pomocniczy wyświetlający listę filmów:
#### `GET /api/movies/`

-   **Description**: Searches for movies.
-   **Authentication**: None (public endpoint).
-   **Query Parameters**:
    -   `search` (string): The search query for the movie title (e.g., `?search=interstellar`).
-   **Success Response** (200 OK):
    ```json
    [
      {
        "tconst": "tt0816692",
        "primary_title": "Interstellar",
        "start_year": 2014,
        "avg_rating": "8.6",
        "poster_path": "https://image.tmdb.org/t/p/w500/gEU2QniE6E77NI6lCU6MxlNBvIx.jpg"
      }
    ]
    ```
</endpoint_description>

5. Endpoint Implementation:
<endpoint_implementation>
@urls.py
@views.py
</endpoint_implementation>

6. Type Definitions:
<type_definitions>
@api.types.ts @database.types.ts 
</type_definitions>

7. Tech Stack:
<tech_stack>
@tech-stack.md
</tech_stack>

Przed utworzeniem ostatecznego planu wdrożenia przeprowadź analizę i planowanie wewnątrz tagów <implementation_breakdown> w swoim bloku myślenia. Ta sekcja może być dość długa, ponieważ ważne jest, aby być dokładnym.

W swoim podziale implementacji wykonaj następujące kroki:
1. Dla każdej sekcji wejściowej (PRD, User Stories, Endpoint Description, Endpoint Implementation, Type Definitions, Tech Stack):
  - Podsumuj kluczowe punkty
 - Wymień wszelkie wymagania lub ograniczenia
 - Zwróć uwagę na wszelkie potencjalne wyzwania lub ważne kwestie
2. Wyodrębnienie i wypisanie kluczowych wymagań z PRD
3. Wypisanie wszystkich potrzebnych głównych komponentów, wraz z krótkim opisem ich opisu, potrzebnych typów, obsługiwanych zdarzeń i warunków walidacji
4. Stworzenie wysokopoziomowego diagramu drzewa komponentów
5. Zidentyfikuj wymagane DTO i niestandardowe typy ViewModel dla każdego komponentu widoku. Szczegółowo wyjaśnij te nowe typy, dzieląc ich pola i powiązane typy.
6. Zidentyfikuj potencjalne zmienne stanu i niestandardowe hooki, wyjaśniając ich cel i sposób ich użycia
7. Wymień wymagane wywołania API i odpowiadające im akcje frontendowe
8. Zmapuj każdej historii użytkownika do konkretnych szczegółów implementacji, komponentów lub funkcji
9. Wymień interakcje użytkownika i ich oczekiwane wyniki
10. Wymień warunki wymagane przez API i jak je weryfikować na poziomie komponentów
11. Zidentyfikuj potencjalne scenariusze błędów i zasugeruj, jak sobie z nimi poradzić
12. Wymień potencjalne wyzwania związane z wdrożeniem tego widoku i zasugeruj możliwe rozwiązania

Po przeprowadzeniu analizy dostarcz plan wdrożenia w formacie Markdown z następującymi sekcjami:

1. Przegląd: Krótkie podsumowanie widoku i jego celu.
2. Routing widoku: Określenie ścieżki, na której widok powinien być dostępny.
3. Struktura komponentów: Zarys głównych komponentów i ich hierarchii.
4. Szczegóły komponentu: Dla każdego komponentu należy opisać:
 - Opis komponentu, jego przeznaczenie i z czego się składa
 - Główne elementy HTML i komponenty dzieci, które budują komponent
 - Obsługiwane zdarzenia
 - Warunki walidacji (szczegółowe warunki, zgodnie z API)
 - Typy (DTO i ViewModel) wymagane przez komponent
 - Propsy, które komponent przyjmuje od rodzica (interfejs komponentu)
5. Typy: Szczegółowy opis typów wymaganych do implementacji widoku, w tym dokładny podział wszelkich nowych typów lub modeli widoku według pól i typów.
6. Zarządzanie stanem: Szczegółowy opis sposobu zarządzania stanem w widoku, określenie, czy wymagany jest customowy hook.
7. Integracja API: Wyjaśnienie sposobu integracji z dostarczonym punktem końcowym. Precyzyjnie wskazuje typy żądania i odpowiedzi.
8. Interakcje użytkownika: Szczegółowy opis interakcji użytkownika i sposobu ich obsługi.
9. Warunki i walidacja: Opisz jakie warunki są weryfikowane przez interfejs, których komponentów dotyczą i jak wpływają one na stan interfejsu
10. Obsługa błędów: Opis sposobu obsługi potencjalnych błędów lub przypadków brzegowych.
11. Kroki implementacji: Przewodnik krok po kroku dotyczący implementacji widoku.

Upewnij się, że Twój plan jest zgodny z PRD, historyjkami użytkownika i uwzględnia dostarczony stack technologiczny.

Ostateczne wyniki powinny być w języku polskim i zapisane w pliku o nazwie .ai/{view-name}-view-implementation-plan.md. Nie uwzględniaj żadnej analizy i planowania w końcowym wyniku.

Oto przykład tego, jak powinien wyglądać plik wyjściowy (treść jest do zastąpienia):

```markdown
# Plan implementacji widoku [Nazwa widoku]

## 1. Przegląd
[Krótki opis widoku i jego celu]

## 2. Routing widoku
[Ścieżka, na której widok powinien być dostępny]

## 3. Struktura komponentów
[Zarys głównych komponentów i ich hierarchii]

## 4. Szczegóły komponentów
### [Nazwa komponentu 1]
- Opis komponentu [opis]
- Główne elementy: [opis]
- Obsługiwane interakcje: [lista]
- Obsługiwana walidacja: [lista, szczegółowa]
- Typy: [lista]
- Propsy: [lista]

### [Nazwa komponentu 2]
[...]

## 5. Typy
[Szczegółowy opis wymaganych typów]

## 6. Zarządzanie stanem
[Opis zarządzania stanem w widoku]

## 7. Integracja API
[Wyjaśnienie integracji z dostarczonym endpointem, wskazanie typów żądania i odpowiedzi]

## 8. Interakcje użytkownika
[Szczegółowy opis interakcji użytkownika]

## 9. Warunki i walidacja
[Szczegółowy opis warunków i ich walidacji]

## 10. Obsługa błędów
[Opis obsługi potencjalnych błędów]

## 11. Kroki implementacji
1. [Krok 1]
2. [Krok 2]
3. [...]
```

Rozpocznij analizę i planowanie już teraz. Twój ostateczny wynik powinien składać się wyłącznie z planu wdrożenia w języku polskim w formacie markdown, który zapiszesz w pliku .ai/{view-name}-view-implementation-plan.md i nie powinien powielać ani powtarzać żadnej pracy wykonanej w podziale implementacji.