<conversation_summary>
<decisions>
1. Używamy `auth_user` (Django) + `user_profile` (1:1) na preferencje i metadane (m.in. onboarding, email_verified=false, country_code domyślnie 'PL').
2. Autentykacja: JWT, bez przechowywania tokenów w DB.
3. Platformy VOD: słownik `platform` + łącznik `user_platform(user_id, platform_id)` z unikatowością pary; bez wersjonowania historii wyborów platform.
4. `movie`: naturalny PK `tconst TEXT`; pola: `title_type='movie'`, `primary_title`, `original_title (opcjonalnie)`, `start_year SMALLINT`, `genres TEXT[]`, `avg_rating NUMERIC(3,1)`, `num_votes INT`, `created_at/updated_at`.
5. Zewnętrzne ID: `movie_external_ids(tconst PK, tmdb_id BIGINT NULL, watchmode_id BIGINT NULL)` z unikatowymi indeksami częściowymi na każdym ID.
6. Plakaty: `movie_assets(poster_path TEXT, poster_last_checked timestamptz)`.
7. Watchlista: `watchlist_item(id, user_id, tconst, added_at, deleted_at, added_from_ai_suggestion BOOLEAN)`; constraint: partial UNIQUE `(user_id, tconst) WHERE deleted_at IS NULL`; limit 10 egzekwowany aplikacyjnie + constraint trigger.
8. Obejrzane: `watched_item(id, user_id, tconst, watched_at)` z unikatowością `(user_id, tconst)`.
9. Brak wzajemnego wykluczenia: film może równocześnie występować w `watchlist_item` i `watched_item`.
10. Dostępność VOD: globalnie w `movie_availability(tconst, platform_id, region_code, is_available BOOLEAN NULL, last_checked, source, details JSONB)` z PK `(tconst, platform_id, region_code)`; domyślny region 'PL'.
11. Przechowujemy szczegóły Watchmode (np. `watchmode_source_id`, `deep_link_url`) w `details JSONB`.
12. Proces odświeżania: `availability_refresh_run(...)` (log runów), opcjonalnie `availability_refresh_item(...)` do śledzenia zmian.
13. Sugestie AI: `ai_suggestion_batch(id, user_id, generated_at, expires_at, prompt TEXT, response JSONB, cost/latency opcjonalnie)` + `ai_suggestion_item(id, batch_id, suggested_title, year, reason, tmdb_id/tconst NULL)`; limit 1/24h przez EXCLUDE (GiST + tstzrange).
14. Onboarding: pola w `user_profile` (`onboarding_started_at`, `onboarding_completed_at`, `onboarding_step`).
15. Analytics: `event(id, user_id NULL, type, occurred_at, props JSONB)` partycjonowane miesięcznie + dzienne snapshoty; logowanie zapytań wyszukiwania (`search_query`) z retencją.
16. Logi integracji: `integration_error_log(...)`, widoczne tylko dla admina.
17. RLS: włączone dla tabel właścicielskich (`watchlist_item`, `watched_item`, `user_platform`, `ai_*`, `event`, `integration_error_log`) z polityką owner-only; tabele globalne (`movie`, `platform`, `movie_availability`, `movie_assets`, `movie_external_ids`) tylko read dla ról nie-serwisowych.
18. Dostęp do DB wyłącznie przez backend Django (rola serwisowa); RLS jako dodatkowa warstwa ochrony.
19. Rozszerzenia: `pg_trgm`, `btree_gist`, `citext`, `unaccent` (wyszukiwanie), opcjonalnie `uuid-ossp`.
20. Indeksy: GIN `pg_trgm` na `unaccent(lower(primary_title))`, BTREE na `start_year`, kompozyty i partiale na dostępność/aktywne pozycje, GIN na `genres`.
21. Partycjonowanie: `event`, `integration_error_log`, `search_query` po miesiącach.
22. Import IMDb: z `title.basics.tsv` i `title.ratings.tsv`; staging → upsert; zakres tylko `titleType='movie'`.
23. RODO: FK `ON DELETE CASCADE` z `auth_user/user_profile` do tabel właścicielskich; transakcyjna funkcja `SECURITY DEFINER` do hard delete.
24. Brak pola `movie.is_active` (nie używamy w MVP).
25. Brak progu `num_votes` dla prezentacji ocen (logika po stronie aplikacji).
26. Brak `popularity_score` w `movie` (MVP).
27. Brak DB CHECK dla `watched_at <= now()` (walidacja po stronie aplikacji).
</decisions>

<matched_recommendations>
1. Naturalny PK `tconst` w `movie` dla prostych integracji (IMDb/TMDB/Watchmode).
2. Soft delete w `watchlist_item` + partial UNIQUE i constraint trigger na limit 10.
3. Tri-stan `is_available` (TRUE/FALSE/NULL) w `movie_availability` + kompozytowy PK i partial indeksy na dostępne rekordy.
4. EXCLUDE (GiST) na oknach czasowych w `ai_suggestion_batch` do limitu 24h.
5. GIN `pg_trgm` na `unaccent(lower(primary_title))` dla szybkiego autocomplete; opcjonalnie FTS.
6. Partycjonowanie miesięczne logów (`event`, `integration_error_log`, `search_query`) + polityki retencji.
7. Rozszerzenia: `pg_trgm`, `btree_gist`, `citext`, `unaccent` dla jakości wyszukiwania i constraintów czasowych.
8. Globalna dostępność w `movie_availability` + region 'PL' z możliwością rozbudowy (słownik `country`, `region_map`).
9. ETL IMDb przez tabele staging i transakcyjny upsert (stabilność importu).
10. RLS owner-only dla tabel użytkownika; tabele referencyjne tylko read; dostęp wyłącznie przez backend (rola serwisowa bez BYPASSRLS).
11. Materializowane widoki/snapshoty (`analytics_daily_snapshot`, `mv_movies_in_use`) dla wydajności i jobów tygodniowych.
12. Indeksy pokrywające użyte sortowania/filtry: `watchlist_item(user_id, deleted_at, added_at DESC)` (partial), `watched_item(user_id, watched_at DESC)`.
13. Zewnętrzne ID z unikatowymi indeksami częściowymi `WHERE ... IS NOT NULL`.
14. JSONB `details/response` z GIN (tylko gdy potrzebne klucze w filtrach).
15. Hard delete (RODO) przez dedykowaną funkcję transakcyjną + kaskady FK.
</matched_recommendations>

<database_planning_summary>
a. Główne wymagania schematu:
- Import i wyszukiwanie filmów (IMDb), przechowywanie ocen i gatunków, szybkie autocomplete.
- Watchlista z limitem 10 i soft delete; równoległa ewidencja obejrzanych.
- Globalna dostępność VOD (Watchmode) po filmie/platformie/regionie z tri-stanem i timestampem.
- Sugestie AI z cache 24h i możliwością dodania do watchlisty.
- Profil użytkownika (platformy VOD, onboarding, kraj) oraz podstawowe analytics i logowanie błędów.

b. Kluczowe encje i relacje:
- `auth_user` 1:1 `user_profile`; `user_profile` 1:N `watchlist_item`, `watched_item`, `event`, `search_query`, `ai_suggestion_batch`.
- `movie` (PK `tconst`) 1:1 `movie_external_ids`, 1:1 `movie_assets`, 1:N `movie_availability`.
- `platform` N:M z `user_profile` przez `user_platform`; `platform` N:M z `movie` przez `movie_availability`.
- `ai_suggestion_batch` 1:N `ai_suggestion_item`.
- `availability_refresh_run` (opcjonalnie) 1:N `availability_refresh_item`.

c. Bezpieczeństwo i skalowalność:
- RLS owner-only dla danych użytkownika; logi integracji dostępne tylko dla adminów.
- Dostęp do bazy wyłącznie przez backend; RLS jako dodatkowa ochrona.
- Partycjonowanie logów i metryk + indeksy częściowe/kompozytowe dla krytycznych ścieżek (watchlista, dostępność).
- Rozszerzenia `pg_trgm`, `unaccent` dla skalowalnego wyszukiwania; `btree_gist` dla constraintów czasowych; `citext` dla unikalności emaili.
- ETL z stagingiem dla IMDb; materializowane widoki i snapshoty dla raportów i jobów.

d. Nierozwiązane/wybrane parametry operacyjne:
- Retencja danych w logach (`event`, `integration_error_log`, `search_query`, `ai_*`): ustalić dokładne TTL (np. 30/60/90 dni).
- Zakres i harmonogram odświeżania materializowanych widoków (`mv_movies_in_use`, `analytics_daily_snapshot`).
- Lista i kody platform (np. `hbomax` vs `max`) – finalizacja słownika `platform`.
- Mapowanie regionów Watchmode→ISO (`region_map`) – wymagany ostateczny zakres i domyślne reguły normalizacji.
- Zakres indeksowania kluczy w `details/response` (JSONB) – które pola będą realnie filtrowane.
</database_planning_summary>

<unresolved_issues>
1. Ustalić konkretne wartości TTL dla retencji (event, integration_error_log, search_query, ai_*).  
Rozstrzygnięcie (MVP): event = 90 dni; integration_error_log = 90 dni; search_query = 60 dni; ai_suggestion_batch/ai_suggestion_item = 30 dni po expires_at; analytics_daily_snapshot – bez TTL (trwałe). Implementacja: partycje miesięczne + codzienny job 02:30 UTC (detach/drop starych partycji); hard delete per użytkownik natychmiast (RODO).
2. Zdefiniować końcową listę platform (code, name) oraz ewentualne mapowania zewnętrznych ID dostawców.  
Rozstrzygnięcie (MVP): lista platform: netflix ("Netflix"), hbomax ("HBO Max"), disneyplus ("Disney+"), primevideo ("Prime Video"), appletvplus ("Apple TV+"). Mapowania: platform_external(platform_id, source, external_id) dla watchmode, tmdb z UNIQUE (source, external_id).
3. Potwierdzić użycie unaccent i/lub FTS w MVP (aktywacja i migracje).  
Rozstrzygnięcie (MVP): włączyć unaccent + pg_trgm; indeks GIN na unaccent(lower(primary_title)). FTS odłożone (v1.1). Opcjonalnie kolumna generowana primary_title_norm dla ponownego użycia indeksu.
4. Zatwierdzić harmonogram odświeżeń materializowanych widoków i snapshotów (godzina, częstotliwość).  
Rozstrzygnięcie (MVP): analytics_daily_snapshot codziennie 00:05 UTC; mv_movies_in_use co godzinę oraz po cotygodniowym jobie; używać REFRESH MATERIALIZED VIEW CONCURRENTLY. Job dostępności: piątki 18:00 Europe/Warsaw; log do availability_refresh_run.  
5. Potwierdzić strategię normalizacji regionów Watchmode (zakres region_map i fallbacki).  
Rozstrzygnięcie (MVP): tylko PL; zasiej country('PL') i region_map('watchmode','PL','PL'). Dla nieznanych mapowań: log do integration_error_log i pominięcie rekordu. movie_availability.region_code z FK do country.code.
6. Określić, które klucze w movie_availability.details i ai_suggestion_batch.response wymagają indeksów JSONB.  
Rozstrzygnięcie (MVP): brak GIN na JSONB. Jeśli potrzebny filtr po typie oferty: indeks wyrażenia na (details->>'type') z partial WHERE is_available IS TRUE AND region_code='PL'. Jeśli wyszukiwanie po watchmode_source_id: indeks wyrażenia na (details->>'watchmode_source_id'). Przy częstych filtrach – przenieść pola do kolumn relacyjnych i zindeksować BTREE.

</unresolved_issues>
</conversation_summary>