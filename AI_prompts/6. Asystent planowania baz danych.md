Jesteś asystentem AI, którego zadaniem jest pomoc w zaplanowaniu schematu bazy danych w PostgreSQL dla MVP (Minimum Viable Product) na podstawie dostarczonych informacji. Twoim celem jest wygenerowanie listy pytań i zaleceń, które zostaną wykorzystane w kolejnym promptowaniu do utworzenia schematu bazy danych, relacji i zasad bezpieczeństwa na poziomie wierszy (RLS).

Prosimy o uważne zapoznanie się z poniższymi informacjami:

<product_requirements>
@prd.md
</product_requirements>

<tech_stack>
@tech-stack.md
</tech_stack>

<przykladowa_baza_imdb>
IMDB_data_set_lite/
</przykladowa_baza_imdb>

Przeanalizuj dostarczone informacje, koncentrując się na aspektach istotnych dla projektowania bazy danych. Rozważ następujące kwestie:

1. Zidentyfikuj kluczowe encje i ich atrybuty na podstawie wymagań produktu.
2. Określ potencjalne relacje między jednostkami.
3. Rozważ typów danych i ograniczeń, które mogą być konieczne.
4. Pomyśl o skalowalności i wpływie na wydajność.
5. Oceń wymagania bezpieczeństwa i ich wpływ na projekt bazy danych.
6. Rozważ wszelkie konkretne funkcje PostgreSQL, które mogą być korzystne dla projektu.

Na podstawie analizy wygeneruj listę pytań i zaleceń. Powinny one dotyczyć wszelkich niejasności, potencjalnych problemów lub obszarów, w których potrzeba więcej informacji, aby stworzyć skuteczny schemat bazy danych. Rozważ pytania dotyczące:

1. Relacje i kardynalność jednostek
2. Typy danych i ograniczenia
3. Strategie indeksowania
4. Partycjonowanie (jeśli dotyczy)
5. Wymagania bezpieczeństwa na poziomie wierszy
6. Rozważania dotyczące wydajności
7. Kwestie skalowalności
8. Integralność i spójność danych
9. Dane jakie należy wykorzystać z przykladowej_bazy_imdb
10. Jakie dane będziemy wykorzystywać z innych źródeł wiedzy (TMDB i Watchmode.com)

Dane wyjściowe powinny mieć następującą strukturę:

<pytania>
Wymień tutaj swoje pytania i zalecenia, ponumerowane dla przejrzystości:

Na przykład:
1. Czy encja „użytkownicy” powinna mieć powiązanie z „postami”?

Rekomendacja: Tak, encja „użytkownicy” powinna mieć powiązanie z „postami”, ponieważ użytkownicy mogą tworzyć posty.
</pytania>

Pamiętaj, że Twoim celem jest dostarczenie kompleksowej listy pytań i zaleceń, które pomogą w stworzeniu solidnego schematu bazy danych PostgreSQL dla MVP. Skoncentruj się na jasności, trafności i dokładności swoich wyników. Nie dołączaj żadnych dodatkowych komentarzy ani wyjaśnień poza określonym formatem wyjściowym.

Kontynuuj ten proces, generując nowe pytania i rekomendacje w oparciu o przekazany kontekst i odpowiedzi użytkownika, dopóki użytkownik wyraźnie nie poprosi o podsumowanie.

Pamiętaj, aby skupić się na jasności, trafności i dokładności wyników. Nie dołączaj żadnych dodatkowych komentarzy ani wyjaśnień poza określonym formatem wyjściowym.

----- Chat GPT-5-high

<pytania>
1. Czy korzystamy z wbudowanego modelu `auth_user` Django jako źródła prawdy dla użytkowników?
Rekomendacja: Tak. Użyj `auth_user` + tabela `user_profile` (1:1) na preferencje i metadane (np. onboarding, ustawienia UI).

2. Czy planujemy przechowywać sesje/refresh tokeny w bazie (sesje vs JWT)?
Rekomendacja: JWT bez przechowywania w DB; opcjonalnie tabela `user_token` dla blacklist/rotacji refresh tokenów, jeśli wymagane.

3. Gdzie przechowujemy wybór platform VOD użytkownika?
Rekomendacja: Tabela słownikowa `platform` i tabela łącznikowa `user_platform(user_id, platform_id)` z unikalnością pary.

4. Jakie pola ma mieć encja `movie` importowana z IMDb?
Rekomendacja: `tconst` (PK), `title_type`, `primary_title`, `start_year`, `genres TEXT[]`, `avg_rating NUMERIC(3,1)`, `num_votes INT`, `created_at`, `updated_at`.

5. Czy używamy `tconst` jako klucza głównego filmu?
Rekomendacja: Tak. `tconst TEXT` jako PK; brak surrogate ID w MVP upraszcza integracje z zewnętrznymi API.

6. Czy importujemy pełną bazę IMDb, czy wariant „lite”?
Rekomendacja: Dev: `IMDB_data_set_lite`; Prod: pełna baza dla filmów `titleType='movie'`. Schemat i indeksy przygotuj pod pełny import.

7. Czy przechowujemy `title_type` i/lub `originalTitle`, mimo że MVP używa tylko `primaryTitle`?
Rekomendacja: Tak, `title_type` do walidacji (tylko `movie`), `original_title` opcjonalnie na przyszłość.

8. Jak modelujemy mapowanie ID z TMDB/Watchmode?
Rekomendacja: Tabela `movie_external_ids(tconst PK, tmdb_id BIGINT NULL, watchmode_id BIGINT NULL, UNIQUE na każdym ID)`.

9. Czy przechowujemy tylko URL plakatu, czy również `poster_path` z TMDB?
Rekomendacja: Przechowuj `poster_path` (string) w `movie_assets` + generuj URL z base CDN; dodaj `poster_last_checked`.

10. Jak identyfikujemy platformy VOD?
Rekomendacja: Tabela `platform(id SERIAL PK, code TEXT UNIQUE, name TEXT)`, np. `netflix`, `hbomax`, `disneyplus`, `primevideo`, `appletvplus`.

11. Jak modelujemy watchlistę z soft delete?
Rekomendacja: `watchlist_item(id, user_id FK, tconst FK, added_at, deleted_at, added_from_ai_suggestion BOOLEAN DEFAULT FALSE)` + unikalność `(user_id, tconst)` dla `deleted_at IS NULL`.

12. Czy limit 10 pozycji na watchliście egzekwować w DB?
Rekomendacja: Aplikacyjnie + constraint trigger DEFERRABLE sprawdzający `COUNT(*) WHERE deleted_at IS NULL <= 10` dla bezpieczeństwa.

13. Jak modelować „Obejrzane”?
Rekomendacja: Osobna tabela `watched_item(id, user_id, tconst, watched_at)` z unikalnością `(user_id, tconst)`.

14. Czy łączyć watchlistę i obejrzane w jedną tabelę statusową?
Rekomendacja: MVP: osobne tabele dla prostoty. Refaktor do `user_movie` ze statusem w przyszłości.

15. Jak przechowujemy dostępność z Watchmode (globalnie vs per użytkownik)?
Rekomendacja: Globalnie per film/platforma/region w `movie_availability(tconst, platform_id, region_code, is_available BOOLEAN NULL, last_checked, source TEXT, details JSONB, UNIQUE(tconst, platform_id, region_code))`.

16. Jaki region dla dostępności?
Rekomendacja: `region_code CHAR(2)` (ISO 3166-1). Domyślnie `PL` w MVP, parametryzowalne w przyszłości.

17. Jak reprezentować „nieznaną” dostępność?
Rekomendacja: `is_available BOOLEAN NULL` (NULL = unknown) + `last_checked` NULL/ts.

18. Czy przechowywać deep-linki/ID źródła z Watchmode?
Rekomendacja: Tak, w `movie_availability.details JSONB` (`watchmode_source_id`, `deep_link_url`), z indeksami GIN na JSONB dla wybranych ścieżek.

19. Jak logujemy harmonogram aktualizacji dostępności?
Rekomendacja: `availability_refresh_run(id, started_at, finished_at, status, stats JSONB)` + FK do zaktualizowanych rekordów opcjonalnie.

20. Czy trzymamy cache sugestii AI przez 24h?
Rekomendacja: Tak. `ai_suggestion_batch(id, user_id, generated_at, expires_at, prompt TEXT, response JSONB)` + `ai_suggestion_item(id, batch_id, suggested_title TEXT, year SMALLINT, reason TEXT, tmdb_id/tconst NULL)`.

21. Jak egzekwować limit 1 batch/24h?
Rekomendacja: `btree_gist` + EXCLUDE constraint: `EXCLUDE USING gist (user_id WITH =, tstzrange(generated_at, expires_at) WITH &&)`.

22. Gdzie zapisywać flagę `added_from_ai_suggestion`?
Rekomendacja: Kolumna na `watchlist_item` ustawiana przy dodaniu z AI.

23. Jak modelować onboarding i jego kroki?
Rekomendacja: `user_profile` z polami: `onboarding_started_at`, `onboarding_completed_at`, `onboarding_step SMALLINT`.

24. Jakie zdarzenia śledzić w analytics?
Rekomendacja: Tabela `event(id, user_id NULL, type TEXT, occurred_at, props JSONB)` z partycjonowaniem miesięcznym.

25. Czy tworzyć dzienne snapshoty do dashboardu?
Rekomendacja: Materializowane widoki/tabele agregatów `analytics_daily_snapshot` odświeżane o północy.

26. Jakie indeksy dla wyszukiwania filmów?
Rekomendacja: `pg_trgm` na `LOWER(primary_title)` (GIN gin_trgm_ops); opcjonalnie `tsvector` dla FTS.

27. Jak indeksować `movie_availability` pod szybkie filtry?
Rekomendacja: Kompozytowy BTREE `(tconst, platform_id, region_code)` + partial na `is_available IS TRUE`.

28. Jak indeksować watchlistę/watched?
Rekomendacja: `(user_id)` i `(user_id, added_at)` na `watchlist_item` (partial `deleted_at IS NULL`); `(user_id, watched_at)` na `watched_item`.

29. Czy indeksować `genres`?
Rekomendacja: GIN na `genres` (`TEXT[]`) dla ewentualnych filtrów gatunków.

30. Jakie typy danych i ograniczenia dla pól filmu?
Rekomendacja: `start_year SMALLINT CHECK BETWEEN 1878 AND EXTRACT(YEAR FROM now())+1`, `avg_rating NUMERIC(3,1) CHECK 0<=<=10`, `num_votes INT CHECK >=0`, `tconst TEXT CHECK tconst ~ '^tt[0-9]+'`.

31. Czy użyć `citext` dla emaila?
Rekomendacja: Tak. `citext` + UNIQUE, aby zapewnić case-insensitive unikalność.

32. Czy wszystkie timestampe trzymamy w UTC?
Rekomendacja: `timestamptz` wszędzie; konwersja w aplikacji.

33. Czy przechowywać raw payloady z zewnętrznych API?
Rekomendacja: Tak, w `details JSONB` (Watchmode) i `response JSONB` (AI) dla debugowania, z retencją (np. 30 dni).

34. Jak obsłużyć duże wolumeny `event` i `integration_error_log`?
Rekomendacja: Partycjonowanie po miesiącu + polityki retencji; indeksy na `(occurred_at)` i `(type)`.

35. Czy tabela `integration_error_log` jest potrzebna?
Rekomendacja: Tak. `integration_error_log(id, source TEXT, message TEXT, user_id NULL, payload JSONB, created_at)`.

36. Jakie RLS chcemy wymusić?
Rekomendacja: Włącz RLS na: `watchlist_item`, `watched_item`, `user_platform`, `ai_suggestion_batch`, `ai_suggestion_item`, `event`, `integration_error_log`. Polityka: `user_id = auth.uid()` (Supabase) lub rola aplikacyjna w Django; globalne tabele (`movie`, `platform`, `movie_availability`, `movie_assets`, `movie_external_ids`) tylko read dla wszystkich, write wyłącznie rola serwisowa.

37. Czy baza będzie dostępna bezpośrednio z frontu (Supabase) czy wyłącznie przez Django?
Rekomendacja: Jeśli wyłącznie przez Django z kontem serwisowym, RLS jako defense-in-depth; jeśli przez Supabase, zaprojektować polityki oparte o `auth.uid()`.

38. Jak wymusić hard delete wszystkich danych użytkownika (RODO)?
Rekomendacja: FK z `ON DELETE CASCADE` z `auth_user`/`user_profile` do wszystkich tabel właścicielskich; operacja w transakcji + kasowanie payloadów w JSONB.

39. Czy zachowujemy dane soft-deletowanych pozycji do analytics?
Rekomendacja: Tak. Soft delete tylko na `watchlist_item` (kolumna `deleted_at`), rekordy pozostają i są widoczne w `event`/agregatach.

40. Jak wykrywać duplikaty na watchliście przy soft delete?
Rekomendacja: Partial UNIQUE na `(user_id, tconst) WHERE deleted_at IS NULL`.

41. Jak wykonywać przywrócenie z „Obejrzane” do watchlisty względem limitu 10?
Rekomendacja: Transakcja: sprawdź licznik aktywnych + `INSERT ... ON CONFLICT DO NOTHING` i obsłuż błąd jako komunikat limitu.

42. Jakie dane z `IMDB_data_set_lite` importujemy?
Rekomendacja: Z `title.basics.tsv`: `tconst`, `titleType`, `primaryTitle`, `startYear`, `genres`; z `title.ratings.tsv`: `tconst`, `averageRating`, `numVotes`; resztę pomiń w MVP.

43. Czy importujemy lokalizacje z `title.akas.tsv`?
Rekomendacja: Nie w MVP (tylko `primaryTitle`); opcjonalnie osobna tabela `movie_title_alt` w przyszłości.

44. Jak odwzorować poster TMDB dla wyników autocomplete?
Rekomendacja: `movie_external_ids.tmdb_id` + `movie_assets.poster_path`; fallback placeholder gdy NULL.

45. Jakie dane będziemy trzymać z Watchmode?
Rekomendacja: Dostępność per `tconst`/platforma/region (`is_available`, `last_checked`), `watchmode_source_id`, `deep_link_url`, `prices`/`type` w `details JSONB`.

46. Jak liczyć „ostatni znany stan” na UI?
Rekomendacja: Używaj `movie_availability.last_checked`; dodaj indeks na `(last_checked)` do batchów odświeżeń.

47. Jak wykrywać filmy bez danych w Watchmode?
Rekomendacja: Brak wiersza lub `is_available IS NULL` → komunikat „Dostępność nieznana”.

48. Czy potrzebna jest tabela `mv_movies_in_use` (materializowany widok filmów z watchlisty)?
Rekomendacja: Tak, dla tygodniowych aktualizacji — DISTINCT `tconst` z `watchlist_item WHERE deleted_at IS NULL`.

49. Jakie role DB zdefiniować?
Rekomendacja: `app_rw` (Django), `celery_worker`, `app_ro` (read-only), `admin`; ogranicz DDL do `admin`.

50. Jak chronić integralność referencyjną między `watchlist_item` i `movie`?
Rekomendacja: FK `watchlist_item.tconst REFERENCES movie(tconst) ON UPDATE CASCADE ON DELETE RESTRICT`.

51. Czy przechowywać `last_login_at`, `registered_at` do analytics?
Rekomendacja: Tak. W `user_profile` lustrzane pola (Django i tak trzyma w `auth_user`).

52. Czy wprowadzać walidację email_verified?
Rekomendacja: `user_profile.email_verified BOOLEAN DEFAULT FALSE` (MVP nie używa, ale przyda się).

53. Jakie klucze główne stosować?
Rekomendacja: `GENERATED ALWAYS AS IDENTITY` dla tabel encji użytkownika; naturalny PK `tconst` dla `movie`.

54. Czy potrzebne są indeksy na `event(type, occurred_at)`?
Rekomendacja: Tak, BTREE na `(type, occurred_at DESC)` + GIN na `props`.

55. Czy potrzebne są ograniczenia unikalności na `ai_suggestion_item` w ramach batcha?
Rekomendacja: UNIQUE `(batch_id, suggested_title, year)`; jeśli podajemy `tconst/tmdb_id` to UNIQUE po ID.

56. Jak logować błędy TMDB/Gemini bez danych osobowych?
Rekomendacja: Trzymaj `user_id` opcjonalnie; maskuj wrażliwe pola w `payload`; RLS selektywny dostęp (admin-only SELECT).

57. Jak liczyć „Wyświetlane: X/Y” dla filtrów?
Rekomendacja: Filtruj po `movie_availability.is_available IS TRUE` na platformach użytkownika (JOIN z `user_platform`); zadbaj o indeksy na kolumnach joinów.

58. Jak poradzić sobie z równoległymi zmianami (np. dodanie i usunięcie tej samej pozycji)?
Rekomendacja: Używaj transakcji i `SELECT ... FOR UPDATE` na `watchlist_item` po `(user_id, tconst)`.

59. Czy trzymać `deleted_at` z `NOT NULL` defaultem?
Rekomendacja: `deleted_at timestamptz NULL`; aktywne = `IS NULL`; partial indeksy na aktywne rekordy.

60. Czy przewidujemy politykę retencji dla `integration_error_log` i `event`?
Rekomendacja: Tak. TTL 30-90 dni (config) + job czyszczący; przy hard delete konta usuń powiązane wiersze natychmiast.

61. Czy wymagamy walidacji `genres` do kontrolowanej listy?
Rekomendacja: MVP: `TEXT[]`; w przyszłości tabela `genre` + `movie_genre` dla spójności.

62. Czy potrzebujemy `UNIQUE(user_id, platform_id)` w `user_platform`?
Rekomendacja: Tak, aby wykluczyć duplikaty wyborów.

63. Jakie rozszerzenia PostgreSQL włączyć?
Rekomendacja: `pg_trgm`, `btree_gist`, `citext`, `uuid-ossp` (jeśli UUID), `pgcrypto` (opcjonalnie).

64. Czy przechowywać „kraj” użytkownika na przyszłość (region dostępności)?
Rekomendacja: `user_profile.country_code CHAR(2)` z default `PL`; później mapuj do `movie_availability.region_code`.

65. Czy wymagamy audytu zmian preferencji platform?
Rekomendacja: MVP: nie; opcjonalnie event `user_platform_updated`.

66. Jak obsłużyć race przy limicie 10?
Rekomendacja: Constraint trigger + serializable/REPEATABLE READ transakcja przy dodaniu; błędy tłumacz na komunikat limitu.

67. Czy potrzebna jest tabela `config` na ustawienia (np. aktywne platformy)?
Rekomendacja: Opcjonalnie `app_config(key TEXT PRIMARY KEY, value JSONB)`.

68. Czy indeksować `movie(start_year)` do sortowania?
Rekomendacja: BTREE na `start_year` dla szybkiego sortowania/filtrów.

69. Czy przechowywać „ostatnia dostępność” per użytkownik?
Rekomendacja: Nie, dostępność jest globalna; filtruj względem `user_platform`.

70. Czy przewidzieć migrację schematu dla przyszłych „seriali”?
Rekomendacja: Trzymaj `title_type`; nie zakładaj ograniczeń na FK zależnych od typu, aby łatwo dodać `tvSeries` później.
</pytania>

----- Moje odpowiedzi

1. Tak. Użyj auth_user + tabela user_profile (1:1) na preferencje i metadane (np. onboarding, ustawienia UI).
2. JWT bez przechowywania w DB
3. Tabela słownikowa platform i tabela łącznikowa user_platform(user_id, platform_id) z unikalnością pary.
4. tconst (PK), title_type, primary_title, start_year, genres TEXT[], avg_rating NUMERIC(3,1), num_votes INT, created_at, updated_at.
5. Tak. tconst TEXT jako PK; brak surrogate ID w MVP upraszcza integracje z zewnętrznymi API.
6. Dev: IMDB_data_set_lite; Prod: pełna baza dla filmów titleType='movie'. Schemat i indeksy przygotuj pod pełny import.
7. Tak, title_type do walidacji (tylko movie), original_title opcjonalnie na przyszłość.
8. Tabela movie_external_ids(tconst PK, tmdb_id BIGINT NULL, watchmode_id BIGINT NULL, UNIQUE na każdym ID).
9. Przechowuj poster_path (string) w movie_assets + generuj URL z base CDN; dodaj poster_last_checked.
10. Tabela platform(id SERIAL PK, code TEXT UNIQUE, name TEXT), np. netflix, hbomax, disneyplus, primevideo, appletvplus.
11. watchlist_item(id, user_id FK, tconst FK, added_at, deleted_at, added_from_ai_suggestion BOOLEAN DEFAULT FALSE) + unikalność (user_id, tconst) dla deleted_at IS NULL.
12. Aplikacyjnie + constraint trigger DEFERRABLE sprawdzający COUNT(*) WHERE deleted_at IS NULL <= 10 dla bezpieczeństwa.
13. Osobna tabela watched_item(id, user_id, tconst, watched_at) z unikalnością (user_id, tconst).
14. MVP: osobne tabele dla prostoty. Refaktor do user_movie ze statusem w przyszłości.
15. Globalnie per film/platforma/region w movie_availability(tconst, platform_id, region_code, is_available BOOLEAN NULL, last_checked, source TEXT, details JSONB, UNIQUE(tconst, platform_id, region_code)).
16. region_code CHAR(2) (ISO 3166-1). Domyślnie PL w MVP, parametryzowalne w przyszłości.
17. is_available BOOLEAN NULL (NULL = unknown) + last_checked NULL/ts.
18.  Tak, w movie_availability.details JSONB (watchmode_source_id, deep_link_url), z indeksami GIN na JSONB dla wybranych ścieżek.
19. availability_refresh_run(id, started_at, finished_at, status, stats JSONB) + FK do zaktualizowanych rekordów opcjonalnie.
20. Tak. ai_suggestion_batch(id, user_id, generated_at, expires_at, prompt TEXT, response JSONB) + ai_suggestion_item(id, batch_id, suggested_title TEXT, year SMALLINT, reason TEXT, tmdb_id/tconst NULL).
21. btree_gist + EXCLUDE constraint: EXCLUDE USING gist (user_id WITH =, tstzrange(generated_at, expires_at) WITH &&).
22. Kolumna na watchlist_item ustawiana przy dodaniu z AI.
23. user_profile z polami: onboarding_started_at, onboarding_completed_at, onboarding_step SMALLINT.
24. Tabela event(id, user_id NULL, type TEXT, occurred_at, props JSONB) z partycjonowaniem miesięcznym.
25. Materializowane widoki/tabele agregatów analytics_daily_snapshot odświeżane o północy.
26. pg_trgm na LOWER(primary_title) (GIN gin_trgm_ops); opcjonalnie tsvector dla FTS.
27. Kompozytowy BTREE (tconst, platform_id, region_code) + partial na is_available IS TRUE.
28. (user_id) i (user_id, added_at) na watchlist_item (partial deleted_at IS NULL); (user_id, watched_at) na watched_item.
29. GIN na genres (TEXT[]) dla ewentualnych filtrów gatunków.
30. start_year SMALLINT CHECK BETWEEN 1878 AND EXTRACT(YEAR FROM now())+1, avg_rating NUMERIC(3,1) CHECK 0<=<=10, num_votes INT CHECK >=0, tconst TEXT CHECK tconst ~ '^tt[0-9]+'.
31.  Tak. citext + UNIQUE, aby zapewnić case-insensitive unikalność.
32. timestamptz wszędzie; konwersja w aplikacji.
33. Tak, w details JSONB (Watchmode) i response JSONB (AI) dla debugowania, z retencją (np. 30 dni).
34. Partycjonowanie po miesiącu + polityki retencji; indeksy na (occurred_at) i (type).
35. Tak. integration_error_log(id, source TEXT, message TEXT, user_id NULL, payload JSONB, created_at).
36. Włącz RLS na: watchlist_item, watched_item, user_platform, ai_suggestion_batch, ai_suggestion_item, event, integration_error_log. Polityka: user_id = auth.uid() (Supabase) lub rola aplikacyjna w Django; globalne tabele (movie, platform, movie_availability, movie_assets, movie_external_ids) tylko read dla wszystkich, write wyłącznie rola serwisowa.
37. wyłącznie przez Django z kontem serwisowym, RLS jako defense-in-depth;
38. FK z ON DELETE CASCADE z auth_user/user_profile do wszystkich tabel właścicielskich; operacja w transakcji + kasowanie payloadów w JSONB.
39. Tak. Soft delete tylko na watchlist_item (kolumna deleted_at), rekordy pozostają i są widoczne w event/agregatach.
40.  Partial UNIQUE na (user_id, tconst) WHERE deleted_at IS NULL.
41. Transakcja: sprawdź licznik aktywnych + INSERT ... ON CONFLICT DO NOTHING i obsłuż błąd jako komunikat limitu.
42. Z title.basics.tsv: tconst, titleType, primaryTitle, startYear, genres; z title.ratings.tsv: tconst, averageRating, numVotes; resztę pomiń w MVP.
43. Nie w MVP (tylko primaryTitle); opcjonalnie osobna tabela movie_title_alt w przyszłości.
44. movie_external_ids.tmdb_id + movie_assets.poster_path; fallback placeholder gdy NULL.
45. Dostępność per tconst/platforma/region (is_available, last_checked), watchmode_source_id, deep_link_url, prices/type w details JSONB.
46. Używaj movie_availability.last_checked; dodaj indeks na (last_checked) do batchów odświeżeń.
47. is_available IS NULL → komunikat „Dostępność nieznana”.
48. Tak, dla tygodniowych aktualizacji — DISTINCT tconst z watchlist_item WHERE deleted_at IS NULL.
49. app_rw (Django), celery_worker, app_ro (read-only), admin; ogranicz DDL do admin.
50. FK watchlist_item.tconst REFERENCES movie(tconst) ON UPDATE CASCADE ON DELETE RESTRICT.
51.  Tak. W user_profile lustrzane pola (Django i tak trzyma w auth_user).
52.  user_profile.email_verified BOOLEAN DEFAULT FALSE (MVP nie używa, ale przyda się).
53. GENERATED ALWAYS AS IDENTITY dla tabel encji użytkownika; naturalny PK tconst dla movie.
54. Tak, BTREE na (type, occurred_at DESC) + GIN na props.
55. UNIQUE (batch_id, suggested_title, year)
56.  maskuj wrażliwe pola w payload; RLS selektywny dostęp (admin-only SELECT).
57. Filtruj po movie_availability.is_available IS TRUE na platformach użytkownika (JOIN z user_platform); zadbaj o indeksy na kolumnach joinów.
58. Używaj transakcji i SELECT ... FOR UPDATE na watchlist_item po (user_id, tconst).
59. deleted_at timestamptz NULL; aktywne = IS NULL; partial indeksy na aktywne rekordy.
60. Tak. TTL 30-90 dni (config) + job czyszczący; przy hard delete konta usuń powiązane wiersze natychmiast.
61. MVP: TEXT[]; w przyszłości tabela genre + movie_genre dla spójności.
62. Tak, aby wykluczyć duplikaty wyborów.
63. pg_trgm, btree_gist, citext, uuid-ossp (jeśli UUID),
64. user_profile.country_code CHAR(2) z default PL; później mapuj do movie_availability.region_code.
65. MVP: nie; opcjonalnie event user_platform_updated.
66. Constraint trigger + serializable/REPEATABLE READ transakcja przy dodaniu; błędy tłumacz na komunikat limitu.
67. nie
68. BTREE na start_year dla szybkiego sortowania/filtrów.
69. Nie, dostępność jest globalna; filtruj względem user_platform.
70.  Trzymaj title_type; nie zakładaj ograniczeń na FK zależnych od typu, aby łatwo dodać tvSeries później.

----- chat GPT-5-High
<pytania>
71. Czy wszystkie tabele operacyjne mają pola `created_at` i `updated_at` z domyślnym `now()` oraz mechanizm automatycznej aktualizacji `updated_at`?
Rekomendacja: Tak. Dodać `created_at timestamptz NOT NULL DEFAULT now()`, `updated_at timestamptz NOT NULL DEFAULT now()` i trigger `updated_at = now()` przy `UPDATE`.

72. Czy wymuszamy wzorzec `NOT NULL` na kluczowych FK i polach referencyjnych (np. `watchlist_item.user_id`, `watchlist_item.tconst`)?
Rekomendacja: Tak. Ustawić `NOT NULL` na krytycznych FK; `NULL` tylko gdy semantyka explicit (np. `ai_suggestion_item.tconst NULL`).

73. Czy chcemy egzekwować wzajemne wykluczenie: dany film nie może być jednocześnie aktywny w `watchlist_item` i w `watched_item` dla tego samego użytkownika?
Rekomendacja: Tak. Trigger po stronie DB: przy `INSERT` do `watched_item` automatycznie soft-delete aktywnej pozycji w `watchlist_item` (jeśli istnieje); przy „przywracaniu” wykonać odwrotnie z kontrolą limitu 10.

74. Czy `movie_availability` ma mieć złożony PK zamiast sztucznego `id`?
Rekomendacja: Tak. Użyć `PRIMARY KEY (tconst, platform_id, region_code)` aby uniknąć duplikatów i uprościć upsert.

75. Czy utrzymujemy słownik krajów do walidacji `region_code`?
Rekomendacja: Tak. Tabela `country(code CHAR(2) PRIMARY KEY, name TEXT)` + FK z `movie_availability.region_code` (domyślnie `PL`).

76. Czy potrzebujemy mapowania zewnętrznych identyfikatorów platform (Watchmode provider IDs)?
Rekomendacja: Tak. Tabela `platform_external(platform_id FK, source TEXT, external_id TEXT, UNIQUE(platform_id, source), UNIQUE(source, external_id))`.

77. Czy chcemy trwale przechowywać wyniki mapowania tconst→TMDB, jeśli występuje brak dopasowania lub wieloznaczność?
Rekomendacja: Tak. `movie_external_ids_match_status ENUM('matched','unmatched','ambiguous')` + `details JSONB` na przyczyny/alternatywy.

78. Czy umożliwiamy akcent-insensitive i case-insensitive wyszukiwanie tytułów?
Rekomendacja: Tak. Włączyć `unaccent` i stworzyć funkcjonalny indeks GIN `pg_trgm` na `unaccent(lower(primary_title))`.

79. Czy budujemy indeks FTS dla przyszłego rozwoju wyszukiwania?
Rekomendacja: Tak (opcjonalnie). `tsvector` z `primary_title` i `start_year`; indeks GIN na generowanej kolumnie.

80. Czy `genres` w `movie` walidujemy do kontrolowanej listy?
Rekomendacja: MVP: zostawić `TEXT[]`; dodać CHECK: wszystkie elementy `<> ''`; później migrować do `genre`/`movie_genre`.

81. Czy definiujemy domeny typów dla kodów (np. `iso_country`, `platform_code`) w celu spójności?
Rekomendacja: Tak. Domeny `iso_country CHAR(2)` i `platform_code TEXT CHECK (platform_code ~ '^[a-z0-9_]+$')`.

82. Czy `movie_external_ids.tmdb_id/watchmode_id` mają być `BIGINT` czy `TEXT` (ze względu na możliwe wiodące zera)?
Rekomendacja: `BIGINT` dla TMDB; Watchmode zazwyczaj `INT/BIGINT`; jeśli źródło używa stringów — przechowuj jako `TEXT` z CHECK cyfr.

83. Czy `movie_assets.poster_path` wymaga unikalności?
Rekomendacja: Nie. Brak UNIQUE; dodać indeks częściowy `(poster_path)` tylko jeśli będzie często filtrowane.

84. Czy `availability_refresh_run` powiązać relacyjnie z aktualizowanymi rekordami?
Rekomendacja: Tak (opcjonalnie). Tabela łącznikowa `availability_refresh_item(run_id, tconst, platform_id, region_code, prev_state, new_state)`.

85. Czy przechowywać `error_reason` per rekord przy błędach integracji dostępności?
Rekomendacja: Tak. Kolumna `error_reason TEXT NULL` w `movie_availability` aktualizowana podczas niepowodzeń; ułatwia diagnostykę.

86. Czy `ai_suggestion_item` powinien preferować identyfikację po `tconst` jeśli da się zmapować?
Rekomendacja: Tak. Kolumny `suggested_tconst TEXT NULL`, `tmdb_id BIGINT NULL`; dążyć do uzupełnienia `tconst` w ETL.

87. Czy wymusić spójność czasową w limicie AI 24h (strefa UTC)?
Rekomendacja: Tak. Używać `timestamptz` i EXCLUDE na `tstzrange(generated_at, expires_at)` w UTC.

88. Czy logować koszt tokenów/latencji dla AI?
Rekomendacja: Tak. Pola `cost_usd NUMERIC(8,4)`, `latency_ms INT` w `ai_suggestion_batch` (pomocne w budżetowaniu).

89. Czy przechowywać historię zmian preferencji platform użytkownika?
Rekomendacja: MVP: nie; jeśli wymagane — `user_platform_history(user_id, platform_id, action, occurred_at)`.

90. Czy dodać tabelę do logowania wyszukiwań użytkownika (metric „Search Queries”)?
Rekomendacja: Tak. `search_query(id, user_id NULL, query TEXT, occurred_at timestamptz, results_count INT)` z retencją i partycjonowaniem.

91. Czy `event.type` powinien mieć słownik lub ograniczenie do listy dozwolonych wartości?
Rekomendacja: Tak. Słownik `event_type(code TEXT PRIMARY KEY, description TEXT)` i CHECK w `event`.

92. Czy użyć partycjonowania deklaratywnego dla `event`, `integration_error_log`, `search_query` po miesiącu?
Rekomendacja: Tak. Partycje miesięczne `YYYYMM`, indeksy lokalne na `(occurred_at)` i `(type)`.

93. Czy dodać indeks pokrywający sortowanie „Data dodania (najnowsze)”?
Rekomendacja: Tak. Indeks złożony `watchlist_item(user_id, deleted_at, added_at DESC)` częściowy `WHERE deleted_at IS NULL`.

94. Czy potrzebujemy indeksu częściowego dla dostępnych pozycji na platformach użytkownika?
Rekomendacja: Tak. `movie_availability(tconst) WHERE is_available IS TRUE AND region_code='PL'`.

95. Czy egzekwować format `tconst` silniejszym CHECK (długość, liczby)?
Rekomendacja: Tak. `CHECK (tconst ~ '^tt[0-9]{7,}$')`.

96. Czy import IMDb wykonywać jako „staging → merge” dla bezpieczeństwa?
Rekomendacja: Tak. Tabele `stg_*` + transakcyjny `MERGE`/`UPSERT`; walidacje i statystyki różnic (insert/update/delete).

97. Czy utrzymywać `movie.is_active` do oznaczania wycofanych rekordów bez kasowania?
Rekomendacja: Nie w MVP; rely on aktualizacja pól; ewentualne usuwanie tylko gdy rekord nieużywany.

98. Czy wymusić `num_votes >= 10` do prezentacji ocen (jak IMDb Top 250)?
Rekomendacja: MVP: nie; logika po stronie aplikacji; można dodać widok/materializowany widok dla rankingów.

99. Czy dodać materializowany widok `mv_active_watchlist` do szybkich JOIN-ów?
Rekomendacja: Tak. `SELECT DISTINCT tconst FROM watchlist_item WHERE deleted_at IS NULL`; odświeżany po batchach.

100. Czy przechowywać „ostatnio sprawdzoną dostępność” na poziomie filmu (agregat)?
Rekomendacja: Tak (opcjonalnie). `movie.last_availability_check timestamptz` ułatwia monitoring.

101. Czy `watchlist_item` potrzebuje pola `position` do manualnego sortowania?
Rekomendacja: MVP: nie; dodać w przyszłości z unikatem `(user_id, position)`.

102. Czy przewidzieć `UNIQUE (user_id, lower(query))` w `search_query` w krótkim oknie czasu, by redukować spam?
Rekomendacja: Nie; agregacja w analytics rozwiąże duplikaty; zachować pełne logi.

103. Czy `integration_error_log` wymaga RLS per użytkownik, czy pełny dostęp tylko dla roli admin?
Rekomendacja: Tylko admin (bezpośrednio lub przez rolę serwisową); RLS polityka `USING false` dla zwykłych użytkowników.

104. Czy dodać politykę RLS „owner-write, owner-read” dla `watchlist_item` i `watched_item`?
Rekomendacja: Tak. `USING (user_id = current_setting('app.user_id')::uuid)` lub Supabase `auth.uid()`; `WITH CHECK` analogicznie.

105. Czy rola aplikacyjna ma BYPASSRLS?
Rekomendacja: Nie dla `app_rw`; tylko odrębna rola administracyjna/serwisowa; preferować explicit `SECURITY DEFINER` funkcje do admin operacji.

106. Czy potrzebujemy funkcji `SECURITY DEFINER` do hard delete konta (RODO)?
Rekomendacja: Tak. Pojedyncza funkcja transakcyjna usuwająca drzewo zależności + czyszczenie payloadów JSONB.

107. Czy przechowywać `deleted_at` strefowo w UTC i zabraniać aktualizacji w przeszłość?
Rekomendacja: Tak. `timestamptz` w UTC; trigger blokujący „cofanie czasu” na `deleted_at`.

108. Czy wdrożyć constraint trigger na limit 10 z `DEFERRABLE INITIALLY IMMEDIATE` czy `DEFERRED`?
Rekomendacja: `DEFERRABLE INITIALLY IMMEDIATE`, z możliwością `SET CONSTRAINTS ... DEFERRED` w operacjach wsadowych.

109. Czy wymagamy spójności `user_profile.country_code` ∈ `country.code`?
Rekomendacja: Tak. FK do `country(code)` z domyślnym `PL`.

110. Czy `ai_suggestion_item.reason` limitujemy długością?
Rekomendacja: Tak. `VARCHAR(512)`; dłuższe teksty w `response JSONB`.

111. Czy przewidzieć indeks na `movie(start_year DESC)` do sortowania po roku?
Rekomendacja: Tak. BTREE na `start_year`; ewentualnie z `avg_rating` dla kompozytowych sortów.

112. Czy dodać `CHECK` dla `avg_rating` (0.0–10.0) poprawnie?
Rekomendacja: Tak. `CHECK (avg_rating BETWEEN 0.0 AND 10.0)`.

113. Czy w `movie_availability.details` indeksować konkretne klucze JSONB (np. `deep_link_url`)?
Rekomendacja: Tylko jeśli używane w filtrach; inaczej GIN na całość wystarczy.

114. Czy utrzymywać tabelę `app_config` na flagi (np. toggle AI, limit 10)?
Rekomendacja: Tak. `app_config(key TEXT PRIMARY KEY, value JSONB)` + cache w aplikacji.

115. Czy chcemy jawnie logować, z jakiego źródła dodano film do watchlisty?
Rekomendacja: Tak. `source ENUM('manual','ai','onboarding')` w `watchlist_item`; `added_from_ai_suggestion` zostawić jako alias/kolumnę pochodną.

116. Czy dodać indeks częściowy `watched_item(user_id, watched_at DESC)`?
Rekomendacja: Tak. Przyspiesza listowanie historii.

117. Czy `watchlist_item` potrzebuje `UNIQUE (user_id, tconst, deleted_at)`?
Rekomendacja: Nie. Wystarczy partial UNIQUE `(user_id, tconst) WHERE deleted_at IS NULL`; historyczne duplikaty są dozwolone.

118. Czy egzekwować spójność `title_type='movie'` na poziomie bazy?
Rekomendacja: Tak. `CHECK (title_type = 'movie')` w `movie` dla importu MVP; później poluzować przy wsparciu seriali.

119. Czy chcemy dodatkowe pole `popularity_score` w `movie` do rankingów?
Rekomendacja: Nie w MVP; utrzymać jako materializowany widok liczony z `avg_rating` i `num_votes`.

120. Czy potrzebujemy „słownika regionów Watchmode” jeśli różni się od ISO?
Rekomendacja: Tak. Tabela `region_map(source TEXT, source_code TEXT, iso_country CHAR(2), UNIQUE(source, source_code))` i normalizacja podczas ETL.

121. Czy wprowadzić `ON UPDATE CASCADE` dla wszystkich FK do `movie(tconst)`?
Rekomendacja: Tak. Ułatwia ewentualne korekty ID; `ON DELETE RESTRICT` by nie usuwać filmów z historią.

122. Czy `user_profile.onboarding_step` wymaga zakresu (1–3) lub `NULL` po zakończeniu?
Rekomendacja: Tak. `SMALLINT CHECK (onboarding_step BETWEEN 1 AND 3)`; po zakończeniu `NULL` i `onboarding_completed_at` ustawione.

123. Czy dodać widok `v_user_available_watchlist` z JOIN filtrem platform dla szybkiego UI?
Rekomendacja: Tak. Widok/funkcja parametryzowana `user_id` redukująca złożoność zapytań na froncie.

124. Czy przechowywać `last_login_at` i `registered_at` lustrzanie w `user_profile` poprzez trigger z `auth_user`?
Rekomendacja: Tak. Trigger synchronizujący (read-model) dla łatwych raportów.

125. Czy przewidzieć indeks na `movie_external_ids(tmdb_id)` i `watchmode_id` z `UNIQUE WHERE ... IS NOT NULL`?
Rekomendacja: Tak. Dwa unikalne indeksy częściowe: `WHERE tmdb_id IS NOT NULL`, `WHERE watchmode_id IS NOT NULL`.

126. Czy `search_query.query` normalizować (trim, lower, unaccent) do kolumny pomocniczej?
Rekomendacja: Tak. Kolumna `query_norm TEXT GENERATED ALWAYS AS (unaccent(lower(query))) STORED` + indeks GIN `pg_trgm`.

127. Czy ustalić politykę retencji dla `ai_suggestion_batch/ai_suggestion_item` (np. 30 dni)?
Rekomendacja: Tak. Job czyszczący przeterminowane batch’e i powiązane itemy.

128. Czy zablokować `UPDATE`/`DELETE` na historycznych rekordach `event`?
Rekomendacja: Tak. Trigger odrzucający modyfikacje po X dniach (poza rolą admin).

129. Czy dodać „checksum importu” dla plików IMDb?
Rekomendacja: Tak. W `import_job` pola `file_sha256`, `rows_read`, `rows_loaded`, `duration_ms`, `success BOOLEAN`.

130. Czy potrzebujemy walidacji, że `watched_at` nie jest w przyszłości?
Rekomendacja: Tak. `CHECK (watched_at <= now())`.
</pytania>

----- Odpowiedzi

73. Nie. Film może być jednocześnie w watchlist_item i w watched_item
89. Nie.
97. Nie
98. Nie
119. Nie
130. Nie. Na poziomie aplikacji będzie blokowana możliwość wybrania daty z przyszłości.
Na pozostałe pytania, które nie odpowiedziałem użyj rekomendacji.

---

Jesteś asystentem AI, którego zadaniem jest podsumowanie rozmowy na temat planowania bazy danych dla MVP i przygotowanie zwięzłego podsumowania dla następnego etapu rozwoju. W historii konwersacji znajdziesz następujące informacje:
1. Dokument wymagań produktu (PRD)
2. Informacje o stacku technologicznym
3. Historia rozmów zawierająca pytania i odpowiedzi
4. Zalecenia dotyczące modelu

Twoim zadaniem jest:
1. Podsumować historii konwersacji, koncentrując się na wszystkich decyzjach związanych z planowaniem bazy danych.
2. Dopasowanie zaleceń modelu do odpowiedzi udzielonych w historii konwersacji. Zidentyfikuj, które zalecenia są istotne w oparciu o dyskusję.
3. Przygotuj szczegółowe podsumowanie rozmowy, które obejmuje:
   a. Główne wymagania dotyczące schematu bazy danych
   b. Kluczowe encje i ich relacje
   c. Ważne kwestie dotyczące bezpieczeństwa i skalowalności
   d. Wszelkie nierozwiązane kwestie lub obszary wymagające dalszego wyjaśnienia
4. Sformatuj wyniki w następujący sposób:

<conversation_summary>
<decisions>
[Wymień decyzje podjęte przez użytkownika, ponumerowane].
</decisions>

<matched_recommendations>
[Lista najistotniejszych zaleceń dopasowanych do rozmowy, ponumerowanych]
</matched_recommendations>

<database_planning_summary> [Podsumowanie planowania bazy danych]
[Podaj szczegółowe podsumowanie rozmowy, w tym elementy wymienione w kroku 3].
</database_planning_summary>

<unresolved_issues>
[Wymień wszelkie nierozwiązane kwestie lub obszary wymagające dalszych wyjaśnień, jeśli takie istnieją]
</unresolved_issues>
</conversation_summary>

Końcowy wynik powinien zawierać tylko treść w formacie markdown. Upewnij się, że Twoje podsumowanie jest jasne, zwięzłe i zapewnia cenne informacje dla następnego etapu planowania bazy danych.