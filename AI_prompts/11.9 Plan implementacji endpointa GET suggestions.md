Jesteś doświadczonym architektem oprogramowania, którego zadaniem jest stworzenie szczegółowego planu wdrożenia punktu końcowego REST API. Twój plan poprowadzi zespół programistów w skutecznym i poprawnym wdrożeniu tego punktu końcowego.

Zanim zaczniemy, zapoznaj się z poniższymi informacjami:

1. Route API specification:
<route_api_specification>
#### `GET /api/suggestions/`

-   **Description**: Generates or retrieves cached AI movie suggestions for the user.
-   **Authentication**: Required.
-   **Rate Limiting**: 1 request per calendar day (based on server date). User can receive new suggestions once per day, regardless of the exact time of previous request.
-   **Success Response** (200 OK):
    ```json
    {
      "expires_at": "2025-10-13T23:59:59Z",
      "suggestions": [
        {
          "tconst": "tt0133093",
          "primary_title": "The Matrix",
          "start_year": 1999,
          "justification": "Because you liked 'Inception', you might enjoy this classic sci-fi movie about simulated reality.",
          "availability": [
            {"platform_id": 2, "platform_name": "HBO Max", "is_available": true}
          ]
        }
      ]
    }
    ```

**Error Responses**:
- `401 Unauthorized`: Missing or invalid authentication
- `404 Not Found`: User has no movies on their watchlist or watched history to base suggestions on
- `429 Too Many Requests`: User has already received suggestions today

**Business Logic**:
- Check if user has cached suggestions generated today (same calendar day, based on server date)
- If suggestions exist from today (same date), return cached suggestions
- If no suggestions from today exist:
  - Validate user has watchlist/watched movies (return 404 if empty)
  - Check rate limit: verify no suggestions were generated today (return 429 if they were)
  - Generate new suggestions using AI (Gemini API)
  - Cache suggestions in `ai_suggestion_batch` table with `expires_at` set to end of current day (23:59:59)
  - Include availability information for user's selected platforms
 - When fetching availability, filter `movie_availability` to `is_available = true` and user's platforms
 - This leverages partial index `movie_availability_available_idx` on (`tconst`, `platform_id`) WHERE `is_available` IS TRUE
- Suggestions are based on user's watchlist and watched history
- Each suggestion includes a personalized justification from AI
- Rate limiting is based on calendar date (server timezone), not 24-hour rolling window
  - Example: Request at 15:00 on Oct 20 → next request allowed at 00:00 on Oct 21
  - This is more user-friendly than "24 hours from last request"
</route_api_specification>

2. Related database resources:
<related_db_resources>
### Table: `ai_suggestion_batch`
Primary table for caching AI-generated movie suggestions.

| Column | Data Type | Constraints | Description |
|---|---|---|---|
| `id` | `bigint` | **Primary Key**, Identity | Unique identifier for the suggestion batch. |
| `user_id` | `uuid` | **Foreign Key** -> `auth.users(id)` ON DELETE CASCADE, Not Null | The user who received the suggestions. |
| `generated_at` | `timestamptz` | Not Null, `default now()` | Timestamp when the suggestions were generated. |
| `expires_at` | `timestamptz` | Not Null | Expiration time for cached suggestions (set to end of day: 23:59:59). |
| `prompt` | `text` | | The user prompt that generated the suggestions. |
| `response` | `jsonb` | | The full JSON response from the AI model. |

**Note**: 
- Cached suggestions are valid until end of the calendar day they were generated.
- Rate limiting is enforced by checking if `generated_at` date matches current server date.
- Old batches (30 days after expiration) are deleted by a cleanup job.

---

### Table: `user_movie`
Source data for AI suggestions - user's watchlist and watched history.

| Column | Data Type | Constraints | Description |
|---|---|---|---|
| `id` | `bigint` | **Primary Key**, Identity | Unique identifier for the interaction. |
| `user_id` | `uuid` | **Foreign Key** -> `auth.users(id)` ON DELETE CASCADE, Not Null | The user associated with this interaction. |
| `tconst` | `text` | **Foreign Key** -> `movie(tconst)` ON DELETE CASCADE, Not Null | The movie associated with this interaction. |
| `watchlisted_at` | `timestamptz` | | Timestamp when the movie was added to the watchlist. |
| `watchlist_deleted_at` | `timestamptz` | | Timestamp for soft-deleting from the watchlist. |
| `watched_at` | `timestamptz` | | Timestamp when the user marked the movie as watched. |
| `added_from_ai_suggestion` | `boolean` | Not Null, `default false` | Flag indicating if it was added from an AI suggestion. |

---

### Table: `movie`
Movie details included in AI suggestions.

| Column | Data Type | Constraints | Description |
|---|---|---|---|
| `tconst` | `text` | **Primary Key** | IMDb unique identifier for the title (e.g., "tt0111161"). |
| `primary_title`| `text` | Not Null | The primary title of the movie. |
| `start_year` | `smallint` | | The release year of the movie. |
| `genres` | `text[]` | | Array of movie genres. |
| `avg_rating` | `numeric(3, 1)` | | Average user rating. |
| `poster_path` | `text` | | URL path to the movie poster (from TMDB). |

---

### Table: `movie_availability`
Availability information for suggested movies on user's platforms.

| Column | Data Type | Constraints | Description |
|---|---|---|---|
| `id` | `bigint` | **Primary Key**, Identity | Surrogate key for the row. |
| `tconst` | `text` | **Foreign Key** -> `movie(tconst)` ON DELETE CASCADE, Not Null | Movie identifier. |
| `platform_id` | `smallint` | **Foreign Key** -> `platform(id)` ON DELETE CASCADE, Not Null | Platform identifier. |
| `is_available` | `boolean` | | Tri-state: `true` (available), `false` (unavailable), `null` (unknown). |
| `last_checked` | `timestamptz` | Not Null | Timestamp of the last availability check. |

**Unique Constraints**:
- **Unique** (`tconst`, `platform_id`) - Ensures one row per movie-platform pair.

---

### Table: `platform`
Platform details for availability information.

| Column | Data Type | Constraints | Description |
|---|---|---|---|
| `id` | `smallint` | **Primary Key**, Identity | Unique identifier for the platform. |
| `platform_slug` | `text` | **Unique**, Not Null | URL-friendly slug (e.g., "netflix"). |
| `platform_name` | `text` | Not Null | User-friendly name (e.g., "Netflix"). |

---

### Table: `user_platform`
User's selected platforms for filtering availability.

| Column | Data Type | Constraints | Description |
|---|---|---|---|
| `id` | `bigint` | **Primary Key**, Identity | Surrogate key for the row. |
| `user_id` | `uuid` | **Foreign Key** -> `auth.users(id)` ON DELETE CASCADE, Not Null | User's identifier. |
| `platform_id` | `smallint` | **Foreign Key** -> `platform(id)` ON DELETE CASCADE, Not Null | Platform's identifier. |

**Unique Constraints**:
- **Unique** (`user_id`, `platform_id`) - Ensures a user subscribes to each platform at most once.

---

### Relationships:
- **`ai_suggestion_batch` → `auth.users`**: Many-to-One. A user can have multiple suggestion batches over time.
- **`user_movie` → `auth.users`**: Many-to-One. Source data for generating suggestions.
- **`user_movie` → `movie`**: Many-to-One. Movie details for suggestions.
- **`movie_availability` → `movie`**: Many-to-One. Availability status for suggested movies.
- **`movie_availability` → `platform`**: Many-to-One. Platform information.
- **`user_platform` → `auth.users`**: Many-to-One. User's selected platforms.

---

### External API Integration:
- **Gemini API**: Used to generate AI movie suggestions based on user's watchlist/watched history.
- Errors during AI generation should be logged to `integration_error_log` table.
</related_db_resources>

3. Definicje typów:
<type_definitions>
TypeScript types are defined in `myVOD/frontend/myVOD/src/types/api.types.ts`
</type_definitions>

4. Tech stack:
<tech_stack>
`.ai/tech-stack.md`.
</tech_stack>

5. Implementation rules:
<implementation_rules>
@shared.mdc
@backend.mdc
@django.mdc
@coding-practices.mdc
</implementation_rules>

Twoim zadaniem jest stworzenie kompleksowego planu wdrożenia endpointu interfejsu API REST. Przed dostarczeniem ostatecznego planu użyj znaczników <analysis>, aby przeanalizować informacje i nakreślić swoje podejście. W tej analizie upewnij się, że:

1. Podsumuj kluczowe punkty specyfikacji API.
2. Wymień wymagane i opcjonalne parametry ze specyfikacji API.
3. Wymień niezbędne typy DTO i Command Modele.
4. Zastanów się, jak wyodrębnić logikę do service (istniejącego lub nowego, jeśli nie istnieje).
5. Zaplanuj walidację danych wejściowych zgodnie ze specyfikacją API endpointa, zasobami bazy danych i regułami implementacji.
6. Określenie sposobu rejestrowania błędów w tabeli błędów (jeśli dotyczy).
7. Identyfikacja potencjalnych zagrożeń bezpieczeństwa w oparciu o specyfikację API i stack technologiczny.
8. Nakreśl potencjalne scenariusze błędów i odpowiadające im kody stanu.

Po przeprowadzeniu analizy utwórz szczegółowy plan wdrożenia w formacie markdown. Plan powinien zawierać następujące sekcje:

1. Przegląd punktu końcowego
2. Szczegóły żądania
3. Szczegóły odpowiedzi
4. Przepływ danych
5. Względy bezpieczeństwa
6. Obsługa błędów
7. Wydajność
8. Kroki implementacji

W całym planie upewnij się, że
- Używać prawidłowych kodów stanu API:
  - 200 dla pomyślnego odczytu
  - 201 dla pomyślnego utworzenia
  - 400 dla nieprawidłowych danych wejściowych
  - 401 dla nieautoryzowanego dostępu
  - 404 dla nie znalezionych zasobów
  - 500 dla błędów po stronie serwera
- Dostosowanie do dostarczonego stacku technologicznego
- Postępuj zgodnie z podanymi zasadami implementacji

Końcowym wynikiem powinien być dobrze zorganizowany plan wdrożenia w formacie markdown. Oto przykład tego, jak powinny wyglądać dane wyjściowe:

``markdown
# API Endpoint Implementation Plan: [Nazwa punktu końcowego]

## 1. Przegląd punktu końcowego
[Krótki opis celu i funkcjonalności punktu końcowego]

## 2. Szczegóły żądania
- Metoda HTTP: [GET/POST/PUT/DELETE]
- Struktura URL: [wzorzec URL]
- Parametry:
  - Wymagane: [Lista wymaganych parametrów]
  - Opcjonalne: [Lista opcjonalnych parametrów]
- Request Body: [Struktura treści żądania, jeśli dotyczy]

## 3. Wykorzystywane typy
[DTOs i Command Modele niezbędne do implementacji]

## 3. Szczegóły odpowiedzi
[Oczekiwana struktura odpowiedzi i kody statusu]

## 4. Przepływ danych
[Opis przepływu danych, w tym interakcji z zewnętrznymi usługami lub bazami danych]

## 5. Względy bezpieczeństwa
[Szczegóły uwierzytelniania, autoryzacji i walidacji danych]

## 6. Obsługa błędów
[Lista potencjalnych błędów i sposób ich obsługi]

## 7. Rozważania dotyczące wydajności
[Potencjalne wąskie gardła i strategie optymalizacji]

## 8. Etapy wdrożenia
1. [Krok 1]
2. [Krok 2]
3. [Krok 3]
...
```

Końcowe wyniki powinny składać się wyłącznie z planu wdrożenia w formacie markdown i nie powinny powielać ani powtarzać żadnej pracy wykonanej w sekcji analizy.

Pamiętaj, aby zapisać swój plan wdrożenia jako .ai/view-implementation-plan.md. Upewnij się, że plan jest szczegółowy, przejrzysty i zapewnia kompleksowe wskazówki dla zespołu programistów.