Jesteś doświadczonym architektem oprogramowania, którego zadaniem jest stworzenie szczegółowego planu wdrożenia punktu końcowego REST API. Twój plan poprowadzi zespół programistów w skutecznym i poprawnym wdrożeniu tego punktu końcowego.

Zanim zaczniemy, zapoznaj się z poniższymi informacjami:

1. Route API specification:
<route_api_specification>
#### `GET /api/me/`

-   **Description**: Retrieves the profile of the currently authenticated user, including their selected platforms.
-   **Authentication**: Required.
-   **Success Response** (200 OK):
    ```json
    {
      "email": "user@example.com",
      "platforms": [
        {"id": 1, "platform_slug": "netflix", "platform_name": "Netflix"},
        {"id": 2, "platform_slug": "hbo-max", "platform_name": "HBO Max"}
      ]
    }
    ```

**Error Responses**:
- `401 Unauthorized`: Missing or invalid authentication

**Business Logic**:
- Returns authenticated user's email and their selected VOD platforms
- Platforms are fetched via the `user_platform` join table

---

#### `PATCH /api/me/`

-   **Description**: Updates the profile of the currently authenticated user, primarily for managing VOD platform selections.
-   **Authentication**: Required.
-   **Request Body**:
    ```json
    {
      "platforms": [1, 3]
    }
    ```

-   **Success Response** (200 OK):
    ```json
    {
      "email": "user@example.com",
      "platforms": [
        {"id": 1, "platform_slug": "netflix", "platform_name": "Netflix"},
        {"id": 3, "platform_slug": "disney-plus", "platform_name": "Disney+"}
      ]
    }
    ```

**Error Responses**:
- `400 Bad Request`: Invalid platform IDs or malformed request body
- `401 Unauthorized`: Missing or invalid authentication

**Business Logic**:
- Replaces user's current platform selections with the provided list
- Validates that all provided platform IDs exist in the `platform` table
- Returns updated user profile with new platform selections
 - Perform idempotent sync: delete subscriptions not present in the request; insert missing; keep existing unchanged
 - Wrap all changes in a single transaction to ensure atomicity and consistency
 - Rely on unique constraint (`user_id`, `platform_id`) to prevent duplicates
</route_api_specification>

2. Related database resources:
<related_db_resources>
### Table: `users` (`auth.users`)
Primary table for user authentication and profile. Managed by Django Auth, not Supabase Auth.

**Key fields:**
- `id` (uuid, primary key) - Used as `user_id` in Django models
- `email` (text) - User's email address
- `encrypted_password` (text) - Password hash (bcrypt via Django)

**How it works:**
- Django creates user records in `auth.users` table via direct SQL inserts during registration
- User IDs are UUIDs generated by the database (`uuid_generate_v4()`)
- Django Auth validates credentials and issues JWTs; Supabase Auth is **not used**
- All user-owned tables have foreign key relationships to `auth.users(id)`

---

### Table: `user_platform`
Many-to-many relationship linking users to their subscribed VOD platforms.

| Column | Data Type | Constraints | Description |
|---|---|---|---|
| `id` | `bigint` | **Primary Key**, Identity | Surrogate key for the row. |
| `user_id` | `uuid` | **Foreign Key** -> `auth.users(id)` ON DELETE CASCADE, Not Null | User's identifier. |
| `platform_id` | `smallint` | **Foreign Key** -> `platform(id)` ON DELETE CASCADE, Not Null | Platform's identifier. |

**Unique Constraints**:
- **Unique** (`user_id`, `platform_id`) - Ensures a user can only subscribe to each platform once.

---

### Table: `platform`
Reference table for VOD platforms.

| Column | Data Type | Constraints | Description |
|---|---|---|---|
| `id` | `smallint` | **Primary Key**, Identity | Unique identifier for the platform. |
| `platform_slug` | `text` | **Unique**, Not Null | URL-friendly slug (e.g., "netflix"). |
| `platform_name` | `text` | Not Null | User-friendly name (e.g., "Netflix"). |

---

### Relationships:
- **`auth.users` → `user_platform`**: One-to-Many. A user can have multiple platform subscriptions.
- **`platform` → `user_platform`**: One-to-Many. A platform can be subscribed to by many users.
- **`user_platform`** connects users with their selected platforms (M:N relationship).
</related_db_resources>

3. Definicje typów:
<type_definitions>
TypeScript types are defined in `myVOD/frontend/myVOD/src/types/api.types.ts`
</type_definitions>

4. Tech stack:
<tech_stack>
`.ai/tech-stack.md`.
</tech_stack>

5. Implementation rules:
<implementation_rules>
@shared.mdc
@backend.mdc
@django.mdc
@coding-practices.mdc
</implementation_rules>

Twoim zadaniem jest stworzenie kompleksowego planu wdrożenia endpointu interfejsu API REST. Przed dostarczeniem ostatecznego planu użyj znaczników <analysis>, aby przeanalizować informacje i nakreślić swoje podejście. W tej analizie upewnij się, że:

1. Podsumuj kluczowe punkty specyfikacji API.
2. Wymień wymagane i opcjonalne parametry ze specyfikacji API.
3. Wymień niezbędne typy DTO i Command Modele.
4. Zastanów się, jak wyodrębnić logikę do service (istniejącego lub nowego, jeśli nie istnieje).
5. Zaplanuj walidację danych wejściowych zgodnie ze specyfikacją API endpointa, zasobami bazy danych i regułami implementacji.
6. Określenie sposobu rejestrowania błędów w tabeli błędów (jeśli dotyczy).
7. Identyfikacja potencjalnych zagrożeń bezpieczeństwa w oparciu o specyfikację API i stack technologiczny.
8. Nakreśl potencjalne scenariusze błędów i odpowiadające im kody stanu.

Po przeprowadzeniu analizy utwórz szczegółowy plan wdrożenia w formacie markdown. Plan powinien zawierać następujące sekcje:

1. Przegląd punktu końcowego
2. Szczegóły żądania
3. Szczegóły odpowiedzi
4. Przepływ danych
5. Względy bezpieczeństwa
6. Obsługa błędów
7. Wydajność
8. Kroki implementacji

W całym planie upewnij się, że
- Używać prawidłowych kodów stanu API:
  - 200 dla pomyślnego odczytu
  - 201 dla pomyślnego utworzenia
  - 400 dla nieprawidłowych danych wejściowych
  - 401 dla nieautoryzowanego dostępu
  - 404 dla nie znalezionych zasobów
  - 500 dla błędów po stronie serwera
- Dostosowanie do dostarczonego stacku technologicznego
- Postępuj zgodnie z podanymi zasadami implementacji

Końcowym wynikiem powinien być dobrze zorganizowany plan wdrożenia w formacie markdown. Oto przykład tego, jak powinny wyglądać dane wyjściowe:

``markdown
# API Endpoint Implementation Plan: [Nazwa punktu końcowego]

## 1. Przegląd punktu końcowego
[Krótki opis celu i funkcjonalności punktu końcowego]

## 2. Szczegóły żądania
- Metoda HTTP: [GET/POST/PUT/DELETE]
- Struktura URL: [wzorzec URL]
- Parametry:
  - Wymagane: [Lista wymaganych parametrów]
  - Opcjonalne: [Lista opcjonalnych parametrów]
- Request Body: [Struktura treści żądania, jeśli dotyczy]

## 3. Wykorzystywane typy
[DTOs i Command Modele niezbędne do implementacji]

## 3. Szczegóły odpowiedzi
[Oczekiwana struktura odpowiedzi i kody statusu]

## 4. Przepływ danych
[Opis przepływu danych, w tym interakcji z zewnętrznymi usługami lub bazami danych]

## 5. Względy bezpieczeństwa
[Szczegóły uwierzytelniania, autoryzacji i walidacji danych]

## 6. Obsługa błędów
[Lista potencjalnych błędów i sposób ich obsługi]

## 7. Rozważania dotyczące wydajności
[Potencjalne wąskie gardła i strategie optymalizacji]

## 8. Etapy wdrożenia
1. [Krok 1]
2. [Krok 2]
3. [Krok 3]
...
```

Końcowe wyniki powinny składać się wyłącznie z planu wdrożenia w formacie markdown i nie powinny powielać ani powtarzać żadnej pracy wykonanej w sekcji analizy.

Pamiętaj, aby zapisać swój plan wdrożenia jako .ai/view-implementation-plan.md. Upewnij się, że plan jest szczegółowy, przejrzysty i zapewnia kompleksowe wskazówki dla zespołu programistów.